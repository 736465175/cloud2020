com.lizhiqiang.springcloud
    1.约定 > 配置 > 编码
步骤
    1.建module
    2.改POM
    3.写yml
    4.main主启动类
    5.业务类

工程重构：entities在消费端和服务端都有，需要抽出来打成jar包 cloud-api-common (entities、工具类、第三方接口等)

客户端消费者80                 -->                         微服务提供者8001
    order                                                 payment 支付
(消费者只需要controller/entities<与服务端一样>)
                                                          view|（前后端分离）json{CommonResult(200,success,data)} <-- controller <-- service <-- dao <--mybatis

Payment 主实体， Json封装体CommonResult<T>，前端后端分离好用

初识微服务使用RestTemplate，它提供了多种便捷访问远程HTTP服务的方法，是一种简单便捷的访问restful服务模板类，是spring提供的用于访问Rest服务的客户端模板工具集
使用RestTemplate： 需要注入到spring容器
    (url,requestMap,ResponseBean.class)


Spring Cloud封装了Netfix 公司开发的Eureka模块来实现服务治理
    管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的注册与发现。
    Eureka采用CS设计架构，Eureka Server是服务注册中心，系统中其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。维护人员通过Eureka Server监控微服务运行状态。
    Eureka 包含两个组件：Eureka Server（提供服务注册功能） 和 Eureka Client(通过注册中心进行访问，发送心跳，周期30S，90秒没法送服务节点被移除)
    ?消费者也需要注册到consumer，成为服务消费者，如果它不对外提供服务，只做消费者，就不需要将自己服务注册

Eureka Server 实质：存key（存服务名），取value(调用地址)
    1.消费者使用服务别名去注册中心获取实际的RPC远程调用地址
    2.消费者获取调用地址后，底层实际是利用HTTPClient技术实现远程调用
    3.消费者获得服务地址后会缓存在本地jvm内存中，默认30秒更新一次服务调用地址

微服务RPC远程调用最核心的是：高可用，搭建Eureka注册中心集群，实现负载均衡+故障容错
    (Eureka注册中心集群实现：即互相注册，相互守望)

消费端 不再关注微服务的ip+port,微服务对外暴露的是微服务名称，consumer使用RestTemplate时，添加负载均衡注解即可,@LoadBalanced
@LoadBalanced 就是Ribbon的负载均衡功能(轮询),它也起到了把服务名(逻辑地址)转化为ip+端口地址


服务发现Discover
    1.对于注册进eureka里面的微服务，可以通过服务发现(DiscoveryClient)来获得该服务的信息
    2.修改cloud-provider-payment8001 的Controller,以及8001主启动类,@EnableDiscoveryClient
    3.@EnableEurekaClient只适用于Eureka作为注册中心，而@EnableDiscoveryClient 可以是其他注册中心。
        它们都能够让注册中心发现，并扫描到该服务（我们的项目）。
        从Spring Cloud Edgware开始，@EnableEurekaClient 或 @EnableDiscoveryClient 是可省略的。
        只需加上相关依赖，并进行相应配置，即可将微服务注册到服务发现组件上。(配置就是yml中的Eureka的配置)




eureka 自我保护：
    某时刻某个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保护；属于CAP里面的AP分支。
    在此模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。是一种对应网络异常的安全保护措施。

zookeeper 做注册中心：服务不可用立即清除，属于CP一致性。


Consul 做注册中心：是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用go语言开发
    提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位
    的服务网格。相当于eureka的接班人
    服务发现、健康监测、KV存储、多数据中心、可视化Web界面

    启动：
        cmd 命令窗口执行：consul agent -dev
        consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面

注册中心总结：
    Eureka     java   AP
    Consul     Go     CP
    Zookeeper  Java   CP
CP：当网络分区出现后，为了保证一致性，就必须拒绝请求，否则无法保证一致性。
    结论：违背了可用性A的要求，只满足一致性和分区容错，即CP

CAP: 理论关注粒度是数据，而不是整体系统设计的策略
    C: consistency 强一致性
    A: Availability 可用性
    P: Partition tolerance 分区容错性


服务调用：
    Ribbon负载均衡服务调用 ： 即负载均衡(@LoadBalanced)+RestTemplate 调用
        基于Netflix 实现的一套 客户端 负载均衡工具
        负载均衡(LB)：
            集中式LB: LB是由服务端实现，独立的LB设施，如Nginx
            进程内LB: 本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。
        工作步骤：
            先选择EurekaServer,再根据用户指定策略选择注册列表中的一个地址
        算法：轮询、随机、加权重等
        修改默认算法：  MyselfRule这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下 ，
            主启动类添加@RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MyselfRule.class)
        轮询算法：核心是，第几次请求数%服务器集群总数量(原理是CAS+自旋锁取index)


    RestTemplate的使用
        getForObject：返回对象为响应体中数据转化成的对象，可以理解成json (推荐使用)
        getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，如消息头、响应状态码、响应体等


    OpenFeign服务接口调用(服务接口绑定器)
        Feign是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可
    前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装，形成了一套模板化的调用方法。
    但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个
    微服务自行封装一些客户端类来包装这些依赖服务的调用，所以，Feign在此基础上做了进一步封装，由他来帮
    助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解方式来配置它(
    以前是Dao接口上的标注Mapper注解，现在是一个微服务接口上的一个Feign注解即可)，即可完成对服务提供
    方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

    Feign集成了Ribbon
        利用Ribbon维护了Payment的服务列表信息，并通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，
        通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务的远程调用。

    OpenFeign 使用方法：(在consumer端使用)
        1.添加依赖 spring-cloud-starter-openfeign
        2.主启动类 添加 @EnableFeignClients 注解
        3.编写业务逻辑接口并添加注解：@FeignClient(value = "CLOUD-PAYMENT-SERVICE"),
            这个接口直接复制provider的Controller方法完美。因为其整合了SpringMVC
        4.编写客户端Controller，调用上面的接口返回。

    OpenFeign 超时控制：需要服务提供方与调用方双方约定时间
        openFeign - ribbon 的调用，客户端一般默认等待1秒钟，超过这个时间得不到服务端返回结果，就会超时报错

        #设置feign客户端超时时间，openFeign默认支持 ribbon
        yml如下
            ribbon:
              #指的是建立连接所用时间，适用于网络状况正常情况下，两端连接所用时间
              ReadTimeout: 5000
              #指建立连接后从服务器读取到可用资源所用时间
              ConnectTimeout: 5000

    OpenFeign 日志打印功能：
           我们可以通过配置来调用日志级别，从而了解Feign 中 HTTP 请求细节
            日志级别：
                NONE：   默认不显示任何日志
                BASIC：  仅记录请求方法、URL、响应状态码及执行时间
                HEADERS：除了BASIC中定义的信息外，还有请求和响应的头信息
                FULL：   除了HEADERS外，还有请求和响应的正文及元数据

            功能使用：
                1.配置日志Bean
                    Logger.Level.FULL; //最全日志
                2.YML文件配置开启日志Feign客户端



Hystrix断路器：(消费端、服务端都可以使用，一般是放在客户端)
    分布式系统面临的问题：复杂的分布式系统的应用有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败。
    Hystrix是一个用于处理分布式系统的 延迟 和 容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，
        比如超时、异常等。Hystrix能够保证在一个依赖出现问题，不会导致整体服务失败，避免级联故障，以提高
        分布式系统的弹性。
    通过断路器的故障监控，向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待
        或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了
        故障在分布式系统中蔓延，乃至雪崩。

    能干嘛：
        服务降级 fallback
            调用失败时，向调用方返回一个符合预期的、可处理的备选响应。
            发生条件： 程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满
        服务熔断 break
            达到最大访问量时，直接拒绝访问；然后调用服务降级的方法，并返回友好提示
        服务限流 flowLimit
            秒杀高并发等操作，排队，有序进行
        接近实时监控

    解决要求：
        8001超时导致服务器变慢：      超时，调用方80不再等待，必须有服务降级
        8001出错(宕机或程序报错):     出错，调用方80要有兜底，必须有服务降级
        8001提供服务OK：             调用方80自己故障或者有自我要求(自己等待时间小于服务提供者处理时间)，自己处理降级

    服务降级：
        服务提供方：
            一般在service层实现类的方法上注解 @HystrixCommand
            主启动类激活： @EnableCircuitBreaker (开启断路器，也支持服务降级)
            设置自身调用超时时间的峰值，峰值内可以正常运行；超过了需要有兜底的方法处理，作服务降级fallback
                @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler" ,commandProperties = {
                        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
                })
            它会单独使用HystrixTimer 线程池分配线程执行 服务降级fallback方法
            当服务不可用、超时 都是使用兜底方案paymentInfo_TimeOutHandler

        服务消费方：
            1.启动类 @EnableHystrix (开启服务降级熔断器，@EnableCircuitBreaker 的升级版?)
            2.业务类 一般在Controller层接口方法上注解 @HystrixCommand
            3.yml要开启feign:hystrix:enabled: true (开启Feign整合hystrix服务降级)

        现有问题：每个业务方法对应一个兜底方法，代码膨胀。那么需要统一fallbackMethod和自定义fallbackMethod分开
            膨胀(Controller层)：
                1.Controller类上注解 @DefaultProperties(defaultFallback="xxx")
                2.Controller层接口方法注解@HystrixCommand，如果@HystrixCommand指定了fallbackMethod就用指定的兜底方法，
                    否则使用@DefaultProperties(defaultFallback="xxx")指定的默认兜底方法

            解耦(openFeign接口系列)：
                1.只需要为客户端@FeignClient注解定义的接口添加一个服务降级处理的实现类，即可实现解耦,这个实现类需要扫描到spring容器；
                    前提是yml要开启feign:hystrix:enabled: true (开启Feign整合hystrix服务降级)
                2.例如 @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-SERVICE", fallback = PaymentFallbackService.class)

    服务熔断CircuitBreaker：
        1.熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长，会进行服务的降级；
            进而熔断该节点微服务的调用，快速返回错误的响应信息。
        2.当检测到该节点微服务调用响应正常后，恢复调用链路(最牛逼的)。服务降级->进而熔断->恢复调用链路
        3.在Spring Cloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的情况，当失败的调用到一定阈值，
            缺省是：10秒内超过20次调用失败率超过50%，就会启动熔断机制。一段时间后(缺省是5秒)断路器进入半开状态，会让
            其中一个请求进行转发，如果成功，断路器会关闭；若失败，继续开启，重复之前。熔断机制的注解也是@HystrixCommand
        4.例子
            1.参数来自 com.netflix.hystrix.HystrixCommandProperties ，配置方式来自官方文档
            2.主启动类添加@EnableCircuitBreaker
            @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback", commandProperties = {
                    @HystrixProperty(name = "circuitBreaker.enabled", value = "true"), //断路器开启
                    @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"), //请求次数
                    @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "10000"),//时间窗口期
                    @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50") //失败率达到多少后跳闸
            })


    服务限流：高级篇讲解alibaba的Sentinel

    服务监控Hystrix Dashboard(接近实时监控，老系统会用<基本淘汰>，新系统基本用alibaba sentinel)
        1.Hystrix提供了准实时的调用监控，会持续记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形化展示给用户。
        Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring cloud也提供了Hystrix Dashboard
        的整合，对监控内容转化成可视化界面。
        2.创建项目：
            1.cloud-consumer-hystrix-dashboard9001
            2.添加依赖spring-cloud-starter-netflix-hystrix-dashboard
            3.主启动类@EnableHystrixDashboard
            4.9001监控首页 http://localhost:9001/hystrix
            5.所有provider微服务提供方(8001/8002..)都需要添加依赖spring-boot-starter-actuator,开启@EnableCircuitBreaker，才支持被9001监控
                provider微服务提供方被监控配置：
                    由于springcloud的坑，主启动类需要修改Bean：ServletRegistrationBean，注入HystrixMetricsStreamServlet，
                        添加addUrlMappings("/hystrix.stream")，具体看启动类
            6.9001监控首页 输入框填入你想监控的服务地址，如：http://localhost:8001/hystrix.stream ，Delay 2000, Title CLOUD-PROVIDER-HYSTRIX-SERVICE



在SpringCloud Gateway新一代服务网关(zuul路由网关已过时)
    1.Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，如：熔断、限流、重试等。
    2.SpringCloud Gateway是原zuul1.x版的替代，Gateway是在Spring生态系统之上构建的API网关服务，基于Spring5、SpringBoot2和Project Reactor等技术。
    3.在Spring Cloud2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，任然还是使用Zuul 1.X非Reactor模式的老版本。
        而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的
        Reactor-netty响应式编程组建，底层通信框架Netty.
    4.SpringCloud Gateway的目标提供统一的路由方式，且基于Filter链的方式提供了网关基本功能，如：安全，监控/指标，限流

    作用：
        1.反向代理
        2.鉴权
        3.流量控制
        4.熔断
        5.日志监控

    特点：基于Spring5、SpringBoot2和Project Reactor等技术，使用非阻塞API
        1.动态路由：能够匹配任何请求属性
        2.可以对路由指定Predicate(断言)和Filter(过滤器)
        3.集成Hystrix的断路器功能
        4.集成SpringCloud服务发现功能
        5.易于编写的Predicate(断言)和Filter(过滤器)
        6.请求限流功能
        7.支持路径重写

    与Zuul的区别：
        1.在SpringCloud Finchley正式版之前，SpringCloud推荐使用Netflix的Zuul网关
        2.Zuul 1.x 是一个基于阻塞I/O的 API Gateway
        3.Zuul 1.x 基于Servlet2.5使用阻塞架构，它不支持任何长连接(如WebSocket)，Zuul 的设计模式和Nginx较像，每次I/O操作
            都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身
            有第一次加载较慢的情况，使得Zuul的性能相对较差
        4.Zuul 2.X 理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前没有整合，Zuul 2.x的性能较Zuul 1.x有较大
            提升。在性能方面，根据官方提供的基准测试，SpringCloud Gateway的RPS(每秒请求数)是Zuul的1.6倍
        5.SpringCloud Gateway 还支持WebSocket

    Spring WebFlux：
        1.传统的Web框架，比如说：struts2，springmvc 等都是基于Servlet API与Servlet 容器基础之上运行的。但是在Servlet3.1
            之后有了异步非阻塞的支持。而WebFlux时一个典型非阻塞异步框架，它的核心是基于Reactor的相关API实现的。相对于传统的
            Web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程。
        2.Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞
            的，并且基于Reactor来实现响应式流规范。

    三大核心概念：
        1.Route(路由) ：   路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由
        2.Predicate(断言)：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(如请求头或
            请求参数)，如果请求与断言相匹配则进行路由。
        3.Filter(过滤)：   指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

    工作原理：路由转发+执行过滤器链
        1.客户端向Spring Cloud Gateway发出请求，然后在Gateway Handler Mapping 中找到与请求相匹配的路由，
            将其发送到Gateway Web Handler
        2.Web Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
        3.过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前("pre")或之后("post")执行业务逻辑。
            Filter在 pre 类型的过滤器可以做 参数校验、权限校验、流量监控、日志输出、协议转换等；
            在 post 类型的过滤器中可以做响应内容、响应头的修改，日志输出，流量监控等

    使用：
        1.我们目前不想暴露8001端口，希望在8001外面套一层9527,gateway项目配置如下yml
            spring:
              application:
                name: cloud-gateway
              #Gateway配置
              cloud:
                gateway:
                  routes:
                    - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/get/**    #断言，路径相匹配的进行路由

                    - id: payment_routh2           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/lb/**    #断言，路径相匹配的进行路由
            eureka:
              client:
                ...

        2.依赖
            spring-cloud-starter-gateway
            spring-cloud-starter-netflix-eureka-client
            不依赖 spring-boot-starter-web、spring-boot-starter-actuator，否则无法启动
            启动后 http://localhost:9527/payment/get/3 也能获取数据

        3.Gateway网关路由有两种配置方式：
            1.如1所示，在yml中配置 (推荐)
            2.代码中注入RouteLocator的Bean

        4.通过微服务名实现动态路由
            1.默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径，创建动态路由进行转发，
                从而实现动态路由的功能
            2.yml修改
                1.需要注意的是uri的协议是lb，表示启用Gateway的负载均衡功能。
                2.lb://serviceName 是spring cloud Gateway在微服务中自动为我们创建的负载均衡uri。
                    spring:
                      application:
                        name: cloud-gateway
                      #Gateway配置
                      cloud:
                        gateway:
                          discovery:
                            locator:
                              enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
                          routes:
                            - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                              uri: lb://cloud-payment-service  #匹配后提供服务的路由地址 （动态路由）
                              predicates:
                                - Path=/payment/get/**    #断言，路径相匹配的进行路由

        5.Predicate的使用
            1.理论
                1.spring cloud Gateway 将路由匹配作为 Spring WebFlux HandlerMapping基础架构的一部分。
                2.spring cloud Gateway 包括许多内置的Route Predicate工厂，所有这些Predicate都与HTTP请求的不同属性匹配。
                    多个Route Predicate工厂可以进行组合
                3.spring cloud Gateway 创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以
                    赋值给Route。
                4.所有这些谓词都匹配HTTP请求的不同属性，多种谓词工厂可以组合，并通过逻辑and
            2.共13种路由断言方式
                [After][Before][Between][Cookie][Header][Host][Method][Path][Query]
                [ReadBodyPredicateFactory][RemoteAddr][Weight][CloudFoundryRouteService]
                1. - Path=/payment/lb/**    #断言，路径相匹配的进行路由
                2. - After=2020-09-15T15:07:39.177+08:00[Asia/Shanghai] 时间格式是美国格式，需要通过代码生成中国时间的美国格式 ZonedDateTime.now()
                3. - Cookie=username,lzq
                4. - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式
                5. - Method=GET
            3.jmeter，postman，curl 测试
                curl测试：底层get/post命令
                curl http://localhost:9527/payment/lb
                curl http://localhost:9527/payment/lb --cookie "username=lzq"
                curl http://localhost:9527/payment/lb -H "X-Request-Id:1234"
                    - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式

        6.Filter(过滤)：指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。
            1.路由过滤器可以用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。
            2.spring cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生
            3.生命周期：pre（路由前）、post（路由后）
            4.种类：GatewayFilter（单一的31个）、GlobalFilter（全局的10个）
            5.常用过滤器 AddRequestParameter   yml 配置(简单不是重点，重点是全局的自定义过滤器)
                filters:
                    - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头上加一对请求头，名称为X-Request-Id值为1024
            6.自定义全局过滤器（推荐使用）
                1.主要是实现GlobalFilter、Ordered 两个接口
                2.作用：全局日志记录、统一网关鉴权。。。


SpringCloud Config 分布式配置中心
    1.分布式系统面临的配置问题：
        由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的，一处修改，处处生效。
        SpringCloud 提供了ConfigService来解决这个问题。
    2.SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持(配置服务器为 各个不同微服务应用 的所有环境提供了
        一个 中心化的外部配置)
    3.SpringCloud Config分为服务端和客户端<就是provider A/B/C>两部分
        服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息
            等访问接口。
        客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，
            配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的
            管理和访问配置内容。
    4.作用：
        1.集中管理配置文件
        2.分环境部署
        3.运行时动态调整配置
        4.自动化加载最新的配置
        5.将配置信息以REST接口的形式暴露

    5.使用
        1.服务端：
            1.git 地址 https://github.com/736465175/springcloud-config.git  账户 736465175  密码 lzq19910214
            2. 多个环境配置文件，保存格式必须UTF-8，如果需要修改，命名 git add , git commit -m "init yml" ,git push origin master
            3.依赖
                spring-cloud-config-server ，spring-cloud-starter-netflix-eureka-client
            4.yml配置
                spring:
                  application:
                    name: cloud-config-center
                  cloud:
                    config:
                      server:
                        git:
                          uri: https://github.com/736465175/springcloud-config.git #github上面的git仓库名
                          #搜索目录
                          search-paths:
                            - springcloud-config
                          #读取分支
                      label: master
            5.主启动类添加 @EnableConfigServer
            6.hosts修改 增加映射 127.0.0.1 config-3344.com
                C:\Windows\System32\drivers\etc
            7.启动项目（先启动Eureka） 访问 http://config-3344.com:3344/master/config-dev.yml
                成功读取到 github上读取内容
            8.严格配置读取规则
                1./{label(分支)}/{application(文件名,可以是微服务名称)}-{profile(后缀)}.yml
                    master分支：   http://config-3344.com:3344/master/config-dev.yml
                    dev   分支：   http://config-3344.com:3344/dev/config-dev.yml

        2.客户端：
            1.依赖：spring-cloud-starter-config，spring-cloud-starter-netflix-eureka-client
                    spring-boot-starter-web(缺少无法启动，也不报错！！！)
            2.bootstrap.yml
                说明：
                    1.application.yml 是用户级的资源配置项，bootstrap.yml是系统级的，优先级更高。
                    2.Spring Cloud会创建一个"BootStrap Context"，作为Spring应用的Application Context的
                        父上下文。初始化的时候，BootStrap Context负责从外部源加载配置属性并解析配置。这两
                        上下文共享一个外部获取的'Environment'。
                    3.'BootStrap'属性优先级高，默认情况下，它们不会被本地配置覆盖，'BootStrap Context'和
                        'Application Context' 有着不同的约定，所以新增了一个'bootstrap.yml'文件，保证
                        'BootStrap Context' 和'Application Context'配置分离。
                    4.需要将Client端的application.yml修改为 bootstrap.yml。（热部署修改bootstrap.yml 失效了？？？）

        3.分布式配置的动态刷新问题：
            Linux运维修改GitHub上的配置文件内容，刷新3344发现ConfigServer配置中心立即响应(立即更新)；
                刷新3355发现ConfigClient没有任何响应(没有更新到最新的配置)，除非自己重启或者重新加载。

        4.Config客户端动态刷新(手动版)
            1.修改3355模块，引入pom   spring-boot-starter-actuator (除网关Gateway不需要，其他module都需要)
            2.修改YML，暴露监控接口
                  #暴露监控端点
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: "*"  #统一写法
            3.业务类Controller 类上添加@RefreshScope
            4.还需要运维人员发送Post请求刷新3355，才能成功实现3355刷新到最新配置(需要每个微服务执行以下Post请求)
                curl -X POST http://localhost:3355/actuator/refresh  激活3355加载最新的ConfigServer配置

        5.Config客户端动态刷新(自动版)
            广播，一次通知，处处生效；大范围的自动刷新 ；所以需要消息总线SpringCloud Bus来帮忙


SpringCloud Bus 消息总线
    1.它是SpringCloud Config的绝配，一般是一起使用，实现配置动态刷新。
    2.SpringCloud Bus 是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息
        中间件的功能；目前支持两种消息代理，RabbitMQ 和 Kafka
    3.SpringCloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态变更、事件推送，也可以当做
        微服务间的通信通道。

    4.总线：
        在微服务架构系统中，通常会使用 轻量级的消息代理 来构建一个 共同的消息主题，并让系统中所有微服务实例都连接上来。
            由于 该主题中产生的消息会被所有实例监听和消费，所以称他为消息总线。 在总线上的各个实例，都可以方便的广播
            一些需要让其他连接在该主题上的实例都知道的消息。
    5.基本原理：
        ConfigClient实例都监听MQ中同一个topic(默认是 springCloudBus)。当一个服务刷新数据的时候，它会把这个消息放
            入到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置。

    6.RabbitMQ环境配置：
        1.安装Erlang      http://erlang.org/download/otp_win64_21.3.exe
        2.安装RabbitMQ    https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/
        3.进入RabbitMQ安装目录下的sbin目录,输入以下命令启动管理功能
            1.进入 D:\Program Files (x86)\RabbitMQ_3.7.14\rabbitmq_server-3.7.14\sbin 目录
            2.cmd 输入命令： rabbitmq-plugins enable rabbitmq_management 安装可视化插件
            3.Windows开始下标可以看到插件,点击start启动MQ
        4.访问地址查看是否安装成功
            http://localhost:15672/
        5.输入账号密码登陆guest/guest

    7.SpringCloud Bus动态刷新全局广播
        1.RabbitMQ环境OK
        2.演示广播效果，增加复杂度，以3355为模板新建一个3366
        3.设计思想
            1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置。
            2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。(推荐)
            3.方式二更合适，方式一不合适原因：
                1.因为微服务本身是业务模块，它本身不应该承担刷新配置的职责。
                2.破坏了微服务各节点的对等性
                3.有一定局限性，因网络、迁移等原因受到制约
        4.给cloud-config-center3344配置中心服务端 添加消息总线支持
            1.pom引入spring-boot-starter-bus-amqp 添加消息总线RabbitMQ支持,整合bus和RabbitMQ
                spring-cloud-config-server包含了 springboot-starter  actuator/ web,不用再引入这两包
            2.yml修改， 增加
                #RabbitMQ相关配置
                spring
                  rabbitmq:
                    host: localhost
                    port: 5672
                    username: guest
                    password: guest

                #rabbitmq相关配置，暴露bus刷新配置的端点
                management:
                  endpoints:
                    web:
                      exposure:
                        include: "bus-refresh"

        5.给cloud-config-client3355/3366客户端添加消息总线支持
            1.pom引入spring-boot-starter-bus-amqp 添加消息总线RabbitMQ支持,整合bus和RabbitMQ
            2.yml修改
                #RabbitMQ相关配置
                spring
                  rabbitmq:
                    host: localhost
                    port: 5672
                    username: guest
                    password: guest
                #暴露监控端点
                management:
                    endpoints:
                      web:
                        exposure:
                          include: "*"  #统一写法
        6.测试
            1.全部启动后查看所有配置，修改github上的配置，在查看一下所有服务读取的配置信息
            2.发送POST请求给配置中心：
                curl -X POST http://localhost:3344/actuator/bus-refresh
                激活3344加载最新的git配置，并广播给所有客户端刷新到最新配置

    8.SpringCloud Bus动态刷新定点通知
        1.指定具体某一个实例生效而不是全部
        2.公式：
            发送POST请求给配置中心
                curl -X POST http://localhost:3344/actuator/bus-refresh/{destination}
            通过destination参数类指定需要更新配置的服务或实例，destination=Eureka注册中心上注册的服务名(小写):服务端口
                例如：curl -X POST http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355


SpringCloud Stream 消息驱动：
    1.为什么引入：一种新技术，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动在各种MQ内切换。
    2.是什么：
        1.屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。
        2.官方定义：是一个构建消息驱动微服务的框架。应用程序通过inputs或者outputs来与SpringCloud Stream中的binder(绑定器)对象交互。
            通过我们配置来binding，而SpringCloud Stream的binder对象负责与消息中间件交互。我们只需要清楚如何与SpringCloud Stream
            交互就可以方便的使用消息驱动的方式。
        3.通过使用Spring Integration 来连接消息代理中间件以实现消息事件驱动。SpringCloud Stream为这些供应商的消息中间件产品提供了
            个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。目前仅支持RabbitMQ和Kafka.

    3.stream统一底层差异
        1.通过定义绑定器作为中间层，完美的实现了 应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得
            应用程序不需要再考虑各种不同消息中间件实现。
        2.通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。
        3.Binder ：input(对应于消费者)，output(对应于生产者)
        4.Stream中的消息通信方式遵循了发布-订阅模式：
            主要是 Topic主题进行广播，RabbitMQ就是Exchange、Kafka中就是Topic

    4.SpringCloud Stream 标准流程套路
        消息生产者->业务逻辑->{SpringCloud Stream ： Source  Channel  Binder} ->MQ组件|
        消息消费者->业务逻辑->{SpringCloud Stream ： Sink  Channel  Binder}        <- |
        说明：
            Binder： 连接中间件，屏蔽差异，应用与消息中间件之间的封装。
            Channel: 通道，是Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介
            Source/Sink：输出、输入

    5.编码API和常用注解
        @input          注解标识输入通道，通过该输入通道接收到的消息进入应用程序
        @output         注解标识输出通道，发布的消息将通过该通道离开应用程序
        @StreamListener 监听队列，用于消费者的队列的消息接收
        @EnableBinding  指信道channel和exchange绑定在一起

    6案例说明
        1.新建三个子模块
            1.cloud-stream-rabbitmq-provider8801 生产者
                1.pom引入 spring-cloud-starter-stream-rabbit，spring-cloud-starter-netflix-eureka-client
                    spring-boot-starter-web，spring-boot-starter-actuator
                2.yml配置
                    spring:
                      application:
                        name: cloud-stream-provider
                      cloud:
                        stream:
                          binders: #在此处配置要绑定的rabbitMq的服务信息
                            defaultRabbit:  #表示定义的名称，用于binding整合
                              type: rabbit  #消息组件类型
                              environment:  #设置RabbitMQ的相关的环境配置
                                spring:
                                  #RabbitMQ相关配置,15672是web管理端口
                                  rabbitmq:
                                    host: localhost
                                    port: 5672
                                    username: guest
                                    password: guest
                          bindings: #服务的整合处理
                            output: #这个名字是一个通道的名称，表示是生产者
                              destination: studyExchange  #表示要使用的Exchange名称定义(主题)
                              content-type: application/json #设置消息类型，本次为json，文本则用"text/plain"
                              binder: defaultRabbit #设置要绑定的消息服务的具体设置
                3.主启动类只需要 @SpringBootApplication，开启Eureka注册服务功能H版默认通过配置即可
                4.消息推送接口实现类(MessageProviderImpl)
                    1.类上注释 @EnableBinding(Source.class) ：
                        定义消息的推送管道，cloud stream 架构中提到，这里就是这样编码
                        //@Service 类上不需要该注释，因为这里的service是和Stream-RabbitMQ框架关联的，是配置层(@Configuration)，不是服务层了
                    2.该类注入org.springframework.messaging.MessageChannel output属性
                        boolean sendResult = output.send(MessageBuilder.withPayload(serial).build());
                        //springcloud stream官网告诉我们这样写

            2.cloud-stream-rabbitmq-consumer8802/8803 消费者
                1.pom 引入 同 cloud-stream-rabbitmq-provider8801相同
                2.yml配置 基本同cloud-stream-rabbitmq-provider8801相同，只需要将bindings.output修改为bindings.input表示消息消费者
                3.主启动类只需要 @SpringBootApplication，开启Eureka注册服务功能H版默认通过配置即可
                4.监听器 ReceiveMessageListenerController类，已经不是HTTP接口形式了，只负责监听定义好的目标主题destination: studyExchange(也可以理解订阅)
                    该类注解 @EnableBinding(Sink.class)即可，
                    其次编写方法
                       @StreamListener(Sink.INPUT)
                       public void input(Message<String> message){message.getPayload();...} 即可接收消息

            3.分组消费与持久化
                1.8802,8803运行后有两个问题：http://localhost:8801/sendMessage，出现重复消费问题。
                    解决：在SpringCloud Stream中处于同一个组(group)的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。
                        不同的组才能全面消费(重复消费)，由于默认情况下8802/8803都是用默认分组(系统分配流水号)，导致它们是不同的组，
                        消息被重复消费了。
                2.查看服务是否是同一个组：
                    登陆RabbitMQ  http://localhost:15672/  选择Exchanges->studyExchange(队列名点进去)->This exchange看到两个不同的组名
                        studyExchange.anonymous.BxP_LB_nRNGRuCVqwgrHHA  8802(流水号就是组名)
                        studyExchange.anonymous.kA3OcZqBQ6m0Wkxj4fcvSQ  8803
                3.微服务消费者如何实现分组
                    1.自定义配置分组(先将微服务分配为两个不同的自定义组)
                        1.yml 8802修改,只需要添加bindings.input.group: lizhiqiangA
                          .....
                          bindings: #服务的整合处理
                            input: #这个名字是一个通道的名称，表示是消费者
                              destination: studyExchange  #表示要是用的Exchange名称定义，队列名称
                              content-type: application/json #设置消息类型，本次为json，文本则用"text/plain"
                              binder: defaultRabbit #设置要绑定的消息服务的具体设置
                              group: lizhiqiangA

                    2.自定义配置将微服务分为同一个组，解决重复消费问题
                        8802/8803 bindings.input.group: lizhiqiangA group取名一样

                4.持久化：有了分组属性，就具备了持久化！！！


SpringCloud Sleuth 分布式请求链路跟踪
    1.




















DDL*******************************************************************************
CREATE TABLE public.payment (
	id bigserial PRIMARY key,
	serial varchar(200) default ''
)
WITH (
	OIDS=FALSE
) ;

-- Permissions
GRANT ALL ON TABLE public.payment TO zbscm;




























<!-- sql:里面可以写入一个共同的sql代码，用于提取重复的代码。
        要使用该代码的时候就直接使用<include>标签
        id:为提取的sql代码，取一个id，起标识作用
         -->
    <sql id="select">
        select * from user
    </sql>
    <!-- public User findUserById(int id);
        id:填写在XxxMapper接口中的方法名
        parameterType:填写参数的类型
        resultType:填写方法中返回值的类型，不用写全路径，不区分大小写
    -->
    <select id="findUserById" parameterType="int" resultType="user">
        <!-- include:用于加载提取公共的sql语句，与<sql>标签对应
               refid:填写<sql>标签中的id属性
         -->
        <include refid="select"></include>
        where id = #{id}
    </select>
    <!-- resultMap属性:与resultMap标签一起使用，填写resultMap标签中定义的id属性 -->
    <select id="findAllOrders" resultMap="orders">
        select * from orders
    </select>
    <!-- resultMap标签:用于自定义封装结果
        type:最终结果还是封装到实体类中，type就是指定封装到哪一个类中
        id:与<select>标签中的resultMap中的属性一直，一定要唯一
        <id>:该标签是指定主键封装到实体类中的哪一个属性(可以省略)
        <result>:该标签是其他的列封装到实体类中，一般只需填写实体类中的属性与表中列不同的项即可
            property:填写实体类中的属性，column:填写表中的列名
     -->
    <resultMap type="Orders" id="orders">
        <id property="id" column="id"/>
        <result property="userId" column="user_id"/>
    </resultMap>
    <!--  public void addUser(User user);
        insert:用于执行添加语句；update:执行更新语句
       同样 delete:执行删除语句
     -->
    <insert id="addUser" parameterType="user">
        <!-- selectKey配置主键信息的标签
            keyColumn:对应数据库表中的主键列
            keyProperty:对应实体类中的属性
            after:代表执行下面代码之前，先执行当前里面的代码
         -->
        <selectKey keyColumn="id" keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        insert into user
        (username,sex,address)
        values(#{username},#{sex},#{address})
    </insert>
    <!-- public List<User> findUserBySexAndUsername(User user); -->
    <select id="findUserBySexAndUsername" parameterType="User" resultType="user">
        <!--select * from user  where 1=1 -->
        <include refid="select"></include>
        <!-- where标签:一个where条件语句，通常和<if>标签混合使用 -->
        <where>
            <!-- if标签:执行一个判断语句，成立才会执行标签体内的sql语句
                test:写上条件判断语句
                注意:这里每一个if前面都尽量加上and，如果你是第一个条件，框架会自动帮你把and截取，如果是第二个if就不能省略and
             -->
            <if test="sex != null and sex != ''">
                and sex = #{sex}
            </if>
            <if test="username != null and username != ''">
                and username like '%${username}%'
            </if>
        </where>
    </select>

    <!-- public List<User> findUserByIds(QueryVo vo); -->
    <!-- QueryVo:是一个实体包装类，通常用于封装实体类之外的一些属性-->
    <select id="findUserByIds" parameterType="QueryVo" resultType="user">
        <include refid="select"></include>
        <where>
            <!-- foreach:循环语句，通常多用于参数是集合时，需要对参数进行遍历出来，再进行赋值查询
                collection:参数类型中的集合、数组的名字，例：下面的ids就是QueryVo这个类中的list集合的名字
                item:为遍历该集合起一个变量名，遍历出来的每一个字，都赋值到这个item中
                open:在sql语句前面添加的sql片段
                close:在sql语句后面添加的sql片段
                separator:指定遍历元素之前用什么分隔符
             -->
            <foreach collection="ids" item="id" open="id in(" close=")" separator=",">
                #{id}
            </foreach>
        </where>
    </select>




JDBC Type           Java Type
CHAR                String
VARCHAR             String
LONGVARCHAR         String
NUMERIC             java.math.BigDecimal
DECIMAL             java.math.BigDecimal
BIT             boolean
BOOLEAN             boolean
TINYINT             byte
SMALLINT            short
INTEGER             int
BIGINT              long
REAL                float
FLOAT               double
DOUBLE              double
BINARY              byte[]
VARBINARY           byte[]
LONGVARBINARY               byte[]
DATE                java.sql.Date
TIME                java.sql.Time
TIMESTAMP           java.sql.Timestamp
CLOB                Clob
BLOB                Blob
ARRAY               Array
DISTINCT            mapping of underlying type
STRUCT              Struct
REF                         Ref
DATALINK            java.net.URL[color=red][/color]