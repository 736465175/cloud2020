com.lizhiqiang.springcloud
    1.约定 > 配置 > 编码
步骤
    1.建module
    2.改POM
    3.写yml
    4.main主启动类
    5.业务类

工程重构：entities在消费端和服务端都有，需要抽出来打成jar包 cloud-api-common (entities、工具类、第三方接口等)

客户端消费者80                 -->                         微服务提供者8001
    order                                                 payment 支付
(消费者只需要controller/entities<与服务端一样>)
                                                          view|（前后端分离）json{CommonResult(200,success,data)} <-- controller <-- service <-- dao <--mybatis

Payment 主实体， Json封装体CommonResult<T>，前端后端分离好用

初识微服务使用RestTemplate，它提供了多种便捷访问远程HTTP服务的方法，是一种简单便捷的访问restful服务模板类，是spring提供的用于访问Rest服务的客户端模板工具集
使用RestTemplate： 需要注入到spring容器
    (url,requestMap,ResponseBean.class)


Spring Cloud封装了Netfix 公司开发的Eureka模块来实现服务治理
    管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的注册与发现。
    Eureka采用CS设计架构，Eureka Server是服务注册中心，系统中其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。维护人员通过Eureka Server监控微服务运行状态。
    Eureka 包含两个组件：Eureka Server（提供服务注册功能） 和 Eureka Client(通过注册中心进行访问，发送心跳，周期30S，90秒没法送服务节点被移除)
    ?消费者也需要注册到consumer，成为服务消费者，如果它不对外提供服务，只做消费者，就不需要将自己服务注册

Eureka Server 实质：存key（存服务名），取value(调用地址)
    1.消费者使用服务别名去注册中心获取实际的RPC远程调用地址
    2.消费者获取调用地址后，底层实际是利用HTTPClient技术实现远程调用
    3.消费者获得服务地址后会缓存在本地jvm内存中，默认30秒更新一次服务调用地址

微服务RPC远程调用最核心的是：高可用，搭建Eureka注册中心集群，实现负载均衡+故障容错
    (Eureka注册中心集群实现：即互相注册，相互守望)

消费端 不再关注微服务的ip+port,微服务对外暴露的是微服务名称，consumer使用RestTemplate时，添加负载均衡注解即可,@LoadBalanced
@LoadBalanced 就是Ribbon的负载均衡功能(轮询),它也起到了把服务名(逻辑地址)转化为ip+端口地址


服务发现Discover
    对于注册进eureka里面的微服务，可以通过服务发现(DiscoveryClient)来获得该服务的信息
    修改cloud-provider-payment8001 的Controller,以及8001主启动类,@EnableDiscoveryClient

eureka 自我保护：
    某时刻某个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保护；属于CAP里面的AP分支。
    在此模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。是一种对应网络异常的安全保护措施。

zookeeper 做注册中心：服务不可用立即清除，属于CP一致性。


Consul 做注册中心：是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用go语言开发
    提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位
    的服务网格。相当于eureka的接班人
    服务发现、健康监测、KV存储、多数据中心、可视化Web界面

    启动：
        cmd 命令窗口执行：consul agent -dev
        consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面

注册中心总结：
    Eureka     java   AP
    Consul     Go     CP
    Zookeeper  Java   CP
CP：当网络分区出现后，为了保证一致性，就必须拒绝请求，否则无法保证一致性。
    结论：违背了可用性A的要求，只满足一致性和分区容错，即CP

CAP: 理论关注粒度是数据，而不是整体系统设计的策略
    C: consistency 强一致性
    A: Availability 可用性
    P: Partition tolerance 分区容错性


服务调用：
    Ribbon负载均衡服务调用 ： 即负载均衡(@LoadBalanced)+RestTemplate 调用
        基于Netflix 实现的一套 客户端 负载均衡工具
        负载均衡(LB)：
            集中式LB: LB是由服务端实现，独立的LB设施，如Nginx
            进程内LB: 本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。
        工作步骤：
            先选择EurekaServer,再根据用户指定策略选择注册列表中的一个地址
        算法：轮询、随机、加权重等
        修改默认算法：  MyselfRule这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下 ，
            主启动类添加@RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MyselfRule.class)
        轮询算法：核心是，第几次请求数%服务器集群总数量(原理是CAS+自旋锁取index)


    RestTemplate的使用
        getForObject：返回对象为响应体中数据转化成的对象，可以理解成json (推荐使用)
        getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，如消息头、响应状态码、响应体等


    OpenFeign服务接口调用(服务接口绑定器)
        Feign是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可
    前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装，形成了一套模板化的调用方法。
    但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个
    微服务自行封装一些客户端类来包装这些依赖服务的调用，所以，Feign在此基础上做了进一步封装，由他来帮
    助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解方式来配置它(
    以前是Dao接口上的标注Mapper注解，现在是一个微服务接口上的一个Feign注解即可)，即可完成对服务提供
    方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

    Feign集成了Ribbon
        利用Ribbon维护了Payment的服务列表信息，并通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，
        通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务的远程调用。

    OpenFeign 使用方法：(在consumer端使用)
        1.添加依赖 spring-cloud-starter-openfeign
        2.主启动类 添加 @EnableFeignClients 注解
        3.编写业务逻辑接口并添加注解：@FeignClient(value = "CLOUD-PAYMENT-SERVICE"),
            这个接口直接复制provider的Controller方法完美。因为其整合了SpringMVC
        4.编写客户端Controller，调用上面的接口返回。

    OpenFeign 超时控制：需要服务提供方与调用方双方约定时间
        openFeign - ribbon 的调用，客户端一般默认等待1秒钟，超过这个时间得不到服务端返回结果，就会超时报错

        #设置feign客户端超时时间，openFeign默认支持 ribbon
        yml如下
            ribbon:
              #指的是建立连接所用时间，适用于网络状况正常情况下，两端连接所用时间
              ReadTimeout: 5000
              #指建立连接后从服务器读取到可用资源所用时间
              ConnectTimeout: 5000

    OpenFeign 日志打印功能：
           我们可以通过配置来调用日志级别，从而了解Feign 中 HTTP 请求细节
            日志级别：
                NONE：   默认不显示任何日志
                BASIC：  仅记录请求方法、URL、响应状态码及执行时间
                HEADERS：除了BASIC中定义的信息外，还有请求和响应的头信息
                FULL：   除了HEADERS外，还有请求和响应的正文及元数据

            功能使用：
                1.配置日志Bean
                    Logger.Level.FULL; //最全日志
                2.YML文件配置开启日志Feign客户端



Hystrix断路器：(消费端、服务端都可以使用，一般是放在客户端)
    分布式系统面临的问题：复杂的分布式系统的应用有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败。
    Hystrix是一个用于处理分布式系统的 延迟 和 容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，
        比如超时、异常等。Hystrix能够保证在一个依赖出现问题，不会导致整体服务失败，避免级联故障，以提高
        分布式系统的弹性。
    通过断路器的故障监控，向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待
        或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了
        故障在分布式系统中蔓延，乃至雪崩。

    能干嘛：
        服务降级 fallback
            调用失败时，向调用方返回一个符合预期的、可处理的备选响应。
            发生条件： 程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满
        服务熔断 break
            达到最大访问量时，直接拒绝访问；然后调用服务降级的方法，并返回友好提示
        服务限流 flowLimit
            秒杀高并发等操作，排队，有序进行
        接近实时监控

    解决要求：
        8001超时导致服务器变慢：      超时，调用方80不再等待，必须有服务降级
        8001出错(宕机或程序报错):     出错，调用方80要有兜底，必须有服务降级
        8001提供服务OK：             调用方80自己故障或者有自我要求(自己等待时间小于服务提供者处理时间)，自己处理降级

    服务降级：
        服务提供方：
            一般在service层实现类的方法上注解 @HystrixCommand
            主启动类激活： @EnableCircuitBreaker (开启断路器，也支持服务降级)
            设置自身调用超时时间的峰值，峰值内可以正常运行；超过了需要有兜底的方法处理，作服务降级fallback
                @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler" ,commandProperties = {
                        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
                })
            它会单独使用HystrixTimer 线程池分配线程执行 服务降级fallback方法
            当服务不可用、超时 都是使用兜底方案paymentInfo_TimeOutHandler

        服务消费方：
            1.启动类 @EnableHystrix (开启服务降级熔断器，@EnableCircuitBreaker 的升级版?)
            2.业务类 一般在Controller层接口方法上注解 @HystrixCommand
            3.yml要开启feign:hystrix:enabled: true (开启Feign整合hystrix服务降级)

        现有问题：每个业务方法对应一个兜底方法，代码膨胀。那么需要统一fallbackMethod和自定义fallbackMethod分开
            膨胀(Controller层)：
                1.Controller类上注解 @DefaultProperties(defaultFallback="xxx")
                2.Controller层接口方法注解@HystrixCommand，如果@HystrixCommand指定了fallbackMethod就用指定的兜底方法，
                    否则使用@DefaultProperties(defaultFallback="xxx")指定的默认兜底方法

            解耦(openFeign接口系列)：
                1.只需要为客户端@FeignClient注解定义的接口添加一个服务降级处理的实现类，即可实现解耦,这个实现类需要扫描到spring容器；
                    前提是yml要开启feign:hystrix:enabled: true (开启Feign整合hystrix服务降级)
                2.例如 @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-SERVICE", fallback = PaymentFallbackService.class)

    服务熔断CircuitBreaker：
        1.熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长，会进行服务的降级；
            进而熔断该节点微服务的调用，快速返回错误的响应信息。
        2.当检测到该节点微服务调用响应正常后，恢复调用链路(最牛逼的)。服务降级->进而熔断->恢复调用链路
        3.在Spring Cloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的情况，当失败的调用到一定阈值，
            缺省是：10秒内超过20次调用失败率超过50%，就会启动熔断机制。一段时间后(缺省是5秒)断路器进入半开状态，会让
            其中一个请求进行转发，如果成功，断路器会关闭；若失败，继续开启，重复之前。熔断机制的注解也是@HystrixCommand
        4.例子
            1.参数来自 com.netflix.hystrix.HystrixCommandProperties ，配置方式来自官方文档
            2.主启动类添加@EnableCircuitBreaker
            @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback", commandProperties = {
                    @HystrixProperty(name = "circuitBreaker.enabled", value = "true"), //断路器开启
                    @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"), //请求次数
                    @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "10000"),//时间窗口期
                    @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50") //失败率达到多少后跳闸
            })


    服务限流：高级篇讲解alibaba的Sentinel

    服务监控Hystrix Dashboard(接近实时监控，老系统会用<基本淘汰>，新系统基本用alibaba sentinel)
        1.Hystrix提供了准实时的调用监控，会持续记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形化展示给用户。
        Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring cloud也提供了Hystrix Dashboard
        的整合，对监控内容转化成可视化界面。
        2.创建项目：
            1.cloud-consumer-hystrix-dashboard9001
            2.添加依赖spring-cloud-starter-netflix-hystrix-dashboard
            3.主启动类@EnableHystrixDashboard
            4.9001监控首页 http://localhost:9001/hystrix
            5.所有provider微服务提供方(8001/8002..)都需要添加依赖spring-boot-starter-actuator,开启@EnableCircuitBreaker，才支持被9001监控
                provider微服务提供方被监控配置：
                    由于springcloud的坑，主启动类需要修改Bean：ServletRegistrationBean，注入HystrixMetricsStreamServlet，
                        添加addUrlMappings("/hystrix.stream")，具体看启动类
            6.9001监控首页 输入框填入你想监控的服务地址，如：http://localhost:8001/hystrix.stream ，Delay 2000, Title CLOUD-PROVIDER-HYSTRIX-SERVICE



在SpringCloud Gateway新一代服务网关(zuul路由网关已过时)
    1.Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，如：熔断、限流、重试等。
    2.SpringCloud Gateway是原zuul1.x版的替代，Gateway是在Spring生态系统之上构建的API网关服务，基于Spring5、SpringBoot2和Project Reactor等技术。
    3.在Spring Cloud2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，任然还是使用Zuul 1.X非Reactor模式的老版本。
        而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的
        Reactor-netty响应式编程组建，底层通信框架Netty.
    4.SpringCloud Gateway的目标提供统一的路由方式，且基于Filter链的方式提供了网关基本功能，如：安全，监控/指标，限流

    作用：
        1.反向代理
        2.鉴权
        3.流量控制
        4.熔断
        5.日志监控

    特点：基于Spring5、SpringBoot2和Project Reactor等技术，使用非阻塞API
        1.动态路由：能够匹配任何请求属性
        2.可以对路由指定Predicate(断言)和Filter(过滤器)
        3.集成Hystrix的断路器功能
        4.集成SpringCloud服务发现功能
        5.易于编写的Predicate(断言)和Filter(过滤器)
        6.请求限流功能
        7.支持路径重写

    与Zuul的区别：
        1.在SpringCloud Finchley正式版之前，SpringCloud推荐使用Netflix的Zuul网关
        2.Zuul 1.x 是一个基于阻塞I/O的 API Gateway
        3.Zuul 1.x 基于Servlet2.5使用阻塞架构，它不支持任何长连接(如WebSocket)，Zuul 的设计模式和Nginx较像，每次I/O操作
            都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身
            有第一次加载较慢的情况，使得Zuul的性能相对较差
        4.Zuul 2.X 理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前没有整合，Zuul 2.x的性能较Zuul 1.x有较大
            提升。在性能方面，根据官方提供的基准测试，SpringCloud Gateway的RPS(每秒请求数)是Zuul的1.6倍
        5.SpringCloud Gateway 还支持WebSocket

    Spring WebFlux：
        1.传统的Web框架，比如说：struts2，springmvc 等都是基于Servlet API与Servlet 容器基础之上运行的。但是在Servlet3.1
            之后有了异步非阻塞的支持。而WebFlux时一个典型非阻塞异步框架，它的核心是基于Reactor的相关API实现的。相对于传统的
            Web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程。
        2.Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞
            的，并且基于Reactor来实现响应式流规范。

    三大核心概念：
        1.Route(路由) ：   路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由
        2.Predicate(断言)：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(如请求头或
            请求参数)，如果请求与断言相匹配则进行路由。
        3.Filter(过滤)：   指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

    工作原理：路由转发+执行过滤器链
        1.客户端向Spring Cloud Gateway发出请求，然后在Gateway Handler Mapping 中找到与请求相匹配的路由，
            将其发送到Gateway Web Handler
        2.Web Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
        3.过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前("pre")或之后("post")执行业务逻辑。
            Filter在 pre 类型的过滤器可以做 参数校验、权限校验、流量监控、日志输出、协议转换等；
            在 post 类型的过滤器中可以做响应内容、响应头的修改，日志输出，流量监控等

    使用：
        1.我们目前不想暴露8001端口，希望在8001外面套一层9527,gateway项目配置如下yml
            spring:
              application:
                name: cloud-gateway
              #Gateway配置
              cloud:
                gateway:
                  routes:
                    - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/get/**    #断言，路径相匹配的进行路由

                    - id: payment_routh2           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/lb/**    #断言，路径相匹配的进行路由
            eureka:
              client:
                ...

        2.依赖
            spring-cloud-starter-gateway
            spring-cloud-starter-netflix-eureka-client
            不依赖 spring-boot-starter-web、spring-boot-starter-actuator，否则无法启动
            启动后 http://localhost:9527/payment/get/3 也能获取数据

        3.Gateway网关路由有两种配置方式：
            1.如1所示，在yml中配置 (推荐)
            2.代码中注入RouteLocator的Bean

        4.通过微服务名实现动态路由
            1.默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径，创建动态路由进行转发，
                从而实现动态路由的功能
            2.yml修改
                1.需要注意的是uri的协议是lb，表示启用Gateway的负载均衡功能。
                2.lb://serviceName 是spring cloud Gateway在微服务中自动为我们创建的负载均衡uri。
                    spring:
                      application:
                        name: cloud-gateway
                      #Gateway配置
                      cloud:
                        gateway:
                          discovery:
                            locator:
                              enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
                          routes:
                            - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                              uri: lb://cloud-payment-service  #匹配后提供服务的路由地址 （动态路由）
                              predicates:
                                - Path=/payment/get/**    #断言，路径相匹配的进行路由

        5.Predicate的使用
            1.理论
                1.spring cloud Gateway 将路由匹配作为 Spring WebFlux HandlerMapping基础架构的一部分。
                2.spring cloud Gateway 包括许多内置的Route Predicate工厂，所有这些Predicate都与HTTP请求的不同属性匹配。
                    多个Route Predicate工厂可以进行组合
                3.spring cloud Gateway 创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以
                    赋值给Route。
                4.所有这些谓词都匹配HTTP请求的不同属性，多种谓词工厂可以组合，并通过逻辑and
            2.共13种路由断言方式
                [After][Before][Between][Cookie][Header][Host][Method][Path][Query]
                [ReadBodyPredicateFactory][RemoteAddr][Weight][CloudFoundryRouteService]
                1. - Path=/payment/lb/**    #断言，路径相匹配的进行路由
                2. - After=2020-09-15T15:07:39.177+08:00[Asia/Shanghai] 时间格式是美国格式，需要通过代码生成中国时间的美国格式 ZonedDateTime.now()
                3. - Cookie=username,lzq
                4. - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式
                5. - Method=GET
            3.jmeter，postman，curl 测试
                curl测试：底层get/post命令
                curl http://localhost:9527/payment/lb
                curl http://localhost:9527/payment/lb --cookie "username=lzq"
                curl http://localhost:9527/payment/lb -H "X-Request-Id:1234"
                    - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式

        6.Filter(过滤)：指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。
            1.路由过滤器可以用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。
            2.spring cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生
            3.生命周期：pre（路由前）、post（路由后）
            4.种类：GatewayFilter（单一的31个）、GlobalFilter（全局的10个）
            5.常用过滤器 AddRequestParameter   yml 配置(简单不是重点，重点是全局的自定义过滤器)
                filters:
                    - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头上加一对请求头，名称为X-Request-Id值为1024
            6.自定义全局过滤器（推荐使用）
                1.主要是实现GlobalFilter、Ordered 两个接口
                2.作用：全局日志记录、统一网关鉴权。。。


SpringCloud Config 分布式配置中心
    1.分布式系统面临的配置问题：
        由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的，一处修改，处处生效。
        SpringCloud 提供了ConfigService来解决这个问题。
    2.SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持(配置服务器为 各个不同微服务应用 的所有环境提供了
        一个 中心化的外部配置)
    3.SpringCloud Config分为服务端和客户端<就是provider A/B/C>两部分
        服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息
            等访问接口。
        客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，
            配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的
            管理和访问配置内容。
    4.作用：
        1.集中管理配置文件
        2.分环境部署
        3.运行时动态调整配置
        4.自动化加载最新的配置
        5.将配置信息以REST接口的形式暴露
































DDL*******************************************************************************
CREATE TABLE public.payment (
	id bigserial PRIMARY key,
	serial varchar(200) default ''
)
WITH (
	OIDS=FALSE
) ;

-- Permissions
GRANT ALL ON TABLE public.payment TO zbscm;




























<!-- sql:里面可以写入一个共同的sql代码，用于提取重复的代码。
        要使用该代码的时候就直接使用<include>标签
        id:为提取的sql代码，取一个id，起标识作用
         -->
    <sql id="select">
        select * from user
    </sql>
    <!-- public User findUserById(int id);
        id:填写在XxxMapper接口中的方法名
        parameterType:填写参数的类型
        resultType:填写方法中返回值的类型，不用写全路径，不区分大小写
    -->
    <select id="findUserById" parameterType="int" resultType="user">
        <!-- include:用于加载提取公共的sql语句，与<sql>标签对应
               refid:填写<sql>标签中的id属性
         -->
        <include refid="select"></include>
        where id = #{id}
    </select>
    <!-- resultMap属性:与resultMap标签一起使用，填写resultMap标签中定义的id属性 -->
    <select id="findAllOrders" resultMap="orders">
        select * from orders
    </select>
    <!-- resultMap标签:用于自定义封装结果
        type:最终结果还是封装到实体类中，type就是指定封装到哪一个类中
        id:与<select>标签中的resultMap中的属性一直，一定要唯一
        <id>:该标签是指定主键封装到实体类中的哪一个属性(可以省略)
        <result>:该标签是其他的列封装到实体类中，一般只需填写实体类中的属性与表中列不同的项即可
            property:填写实体类中的属性，column:填写表中的列名
     -->
    <resultMap type="Orders" id="orders">
        <id property="id" column="id"/>
        <result property="userId" column="user_id"/>
    </resultMap>
    <!--  public void addUser(User user);
        insert:用于执行添加语句；update:执行更新语句
       同样 delete:执行删除语句
     -->
    <insert id="addUser" parameterType="user">
        <!-- selectKey配置主键信息的标签
            keyColumn:对应数据库表中的主键列
            keyProperty:对应实体类中的属性
            after:代表执行下面代码之前，先执行当前里面的代码
         -->
        <selectKey keyColumn="id" keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        insert into user
        (username,sex,address)
        values(#{username},#{sex},#{address})
    </insert>
    <!-- public List<User> findUserBySexAndUsername(User user); -->
    <select id="findUserBySexAndUsername" parameterType="User" resultType="user">
        <!--select * from user  where 1=1 -->
        <include refid="select"></include>
        <!-- where标签:一个where条件语句，通常和<if>标签混合使用 -->
        <where>
            <!-- if标签:执行一个判断语句，成立才会执行标签体内的sql语句
                test:写上条件判断语句
                注意:这里每一个if前面都尽量加上and，如果你是第一个条件，框架会自动帮你把and截取，如果是第二个if就不能省略and
             -->
            <if test="sex != null and sex != ''">
                and sex = #{sex}
            </if>
            <if test="username != null and username != ''">
                and username like '%${username}%'
            </if>
        </where>
    </select>

    <!-- public List<User> findUserByIds(QueryVo vo); -->
    <!-- QueryVo:是一个实体包装类，通常用于封装实体类之外的一些属性-->
    <select id="findUserByIds" parameterType="QueryVo" resultType="user">
        <include refid="select"></include>
        <where>
            <!-- foreach:循环语句，通常多用于参数是集合时，需要对参数进行遍历出来，再进行赋值查询
                collection:参数类型中的集合、数组的名字，例：下面的ids就是QueryVo这个类中的list集合的名字
                item:为遍历该集合起一个变量名，遍历出来的每一个字，都赋值到这个item中
                open:在sql语句前面添加的sql片段
                close:在sql语句后面添加的sql片段
                separator:指定遍历元素之前用什么分隔符
             -->
            <foreach collection="ids" item="id" open="id in(" close=")" separator=",">
                #{id}
            </foreach>
        </where>
    </select>




JDBC Type           Java Type
CHAR                String
VARCHAR             String
LONGVARCHAR         String
NUMERIC             java.math.BigDecimal
DECIMAL             java.math.BigDecimal
BIT             boolean
BOOLEAN             boolean
TINYINT             byte
SMALLINT            short
INTEGER             int
BIGINT              long
REAL                float
FLOAT               double
DOUBLE              double
BINARY              byte[]
VARBINARY           byte[]
LONGVARBINARY               byte[]
DATE                java.sql.Date
TIME                java.sql.Time
TIMESTAMP           java.sql.Timestamp
CLOB                Clob
BLOB                Blob
ARRAY               Array
DISTINCT            mapping of underlying type
STRUCT              Struct
REF                         Ref
DATALINK            java.net.URL[color=red][/color]