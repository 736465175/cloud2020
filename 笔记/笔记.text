com.lizhiqiang.springcloud
    1.约定 > 配置 > 编码
步骤
    1.建module
    2.改POM
    3.写yml
    4.main主启动类
    5.业务类

工程重构：entities在消费端和服务端都有，需要抽出来打成jar包 cloud-api-common (entities、工具类、第三方接口等)

客户端消费者80                 -->                         微服务提供者8001
    order                                                 payment 支付
(消费者只需要controller/entities<与服务端一样>)
                                                          view|（前后端分离）json{CommonResult(200,success,data)} <-- controller <-- service <-- dao <--mybatis

Payment 主实体， Json封装体CommonResult<T>，前端后端分离好用

初识微服务使用RestTemplate，它提供了多种便捷访问远程HTTP服务的方法，是一种简单便捷的访问restful服务模板类，是spring提供的用于访问Rest服务的客户端模板工具集
使用RestTemplate： 需要注入到spring容器
    (url,requestMap,ResponseBean.class)


Spring Cloud封装了Netfix 公司开发的Eureka模块来实现服务治理
    管理服务于服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务的注册与发现。
    Eureka采用CS设计架构，Eureka Server是服务注册中心，系统中其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。维护人员通过Eureka Server监控微服务运行状态。
    Eureka 包含两个组件：Eureka Server（提供服务注册功能） 和 Eureka Client(通过注册中心进行访问，发送心跳，周期30S，90秒没法送服务节点被移除)
    ?消费者也需要注册到consumer，成为服务消费者，如果它不对外提供服务，只做消费者，就不需要将自己服务注册

Eureka Server 实质：存key（存服务名），取value(调用地址)
    1.消费者使用服务别名去注册中心获取实际的RPC远程调用地址
    2.消费者获取调用地址后，底层实际是利用HTTPClient技术实现远程调用
    3.消费者获得服务地址后会缓存在本地jvm内存中，默认30秒更新一次服务调用地址

微服务RPC远程调用最核心的是：高可用，搭建Eureka注册中心集群，实现负载均衡+故障容错
    (Eureka注册中心集群实现：即互相注册，相互守望)

消费端 不再关注微服务的ip+port,微服务对外暴露的是微服务名称，consumer使用RestTemplate时，添加负载均衡注解即可,@LoadBalanced
@LoadBalanced 就是Ribbon的负载均衡功能(轮询),它也起到了把服务名(逻辑地址)转化为ip+端口地址


服务发现Discover
    1.对于注册进eureka里面的微服务，可以通过服务发现(DiscoveryClient)来获得该服务的信息
    2.修改cloud-provider-payment8001 的Controller,以及8001主启动类,@EnableDiscoveryClient
    3.@EnableEurekaClient只适用于Eureka作为注册中心，而@EnableDiscoveryClient 可以是其他注册中心。
        它们都能够让注册中心发现，并扫描到该服务（我们的项目）。
        从Spring Cloud Edgware开始，@EnableEurekaClient 或 @EnableDiscoveryClient 是可省略的。
        只需加上相关依赖，并进行相应配置，即可将微服务注册到服务发现组件上。(配置就是yml中的Eureka的配置)




eureka 自我保护：
    某时刻某个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保护；属于CAP里面的AP分支。
    在此模式中，Eureka Server会保护服务注册表中的信息，不再注销任何服务实例。是一种对应网络异常的安全保护措施。

zookeeper 做注册中心：服务不可用立即清除，属于CP一致性。


Consul 做注册中心：是一套开源的分布式服务发现和配置管理系统，由HashiCorp公司用go语言开发
    提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位
    的服务网格。相当于eureka的接班人
    服务发现、健康监测、KV存储、多数据中心、可视化Web界面

    启动：
        cmd 命令窗口执行：consul agent -dev
        consul 自带 UI 界面，打开网址：http://localhost:8500 ，可以看到当前注册的服务界面

注册中心总结：
    1.Eureka     java   AP
    2.Consul     Go     CP
    3.Zookeeper  Java   CP
    4.Nacos      Java   AP/CP模型可切换，支持控制台管理
CP：当网络分区出现后，为了保证一致性，就必须拒绝请求，否则无法保证一致性。
    结论：违背了可用性A的要求，只满足一致性和分区容错，即CP

CAP: 理论关注粒度是数据，而不是整体系统设计的策略
    C: consistency 强一致性
    A: Availability 可用性
    P: Partition tolerance 分区容错性


服务调用：
    Ribbon负载均衡服务调用 ： 即负载均衡(@LoadBalanced)+RestTemplate 调用
        1.基于Netflix 实现的一套 客户端 负载均衡工具
        2.负载均衡(LB)：
            集中式LB: LB是由服务端实现，独立的LB设施，如Nginx
            进程内LB: 本地负载均衡，在调用微服务接口时，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。
        3.工作步骤：
            先选择EurekaServer,再根据用户指定策略选择注册列表中的一个地址
        4.算法：轮询、随机、加权重等
        5.修改默认算法：
            1.MyselfRule这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下 ，
            2.主启动类添加@RibbonClient(name = "CLOUD-PAYMENT-SERVICE", configuration = MyselfRule.class)
            3.取消RestTemplate的 @LoadBalanced 注解。
            4.MyLoaderBalancer 接口和实现类，只能通过MyLoaderBalancer的instance方法拿到服务端的真实IP地址来调用，
            5.没有注解@LoadBalanced 的RestTemplate 来通过微服务名称来调用肯定会报错，所有Controller层接口都得重写！！！
        6.轮询算法：核心是，第几次请求数%服务器集群总数量(原理是CAS+自旋锁取index)


    RestTemplate的使用
        getForObject：返回对象为响应体中数据转化成的对象，可以理解成json (推荐使用)
        getForEntity：返回对象为ResponseEntity对象，包含了响应中的一些重要信息，如消息头、响应状态码、响应体等


    OpenFeign服务接口调用(服务接口绑定器)
        Feign是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需要创建一个接口并在接口上添加注解即可
    前面在使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装，形成了一套模板化的调用方法。
    但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个
    微服务自行封装一些客户端类来包装这些依赖服务的调用，所以，Feign在此基础上做了进一步封装，由他来帮
    助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解方式来配置它(
    以前是Dao接口上的标注Mapper注解，现在是一个微服务接口上的一个Feign注解即可)，即可完成对服务提供
    方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。

    Feign集成了Ribbon
        利用Ribbon维护了Payment的服务列表信息，并通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，
        通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务的远程调用。

    OpenFeign 使用方法：(在consumer端使用)
        1.添加依赖 spring-cloud-starter-openfeign
        2.主启动类 添加 @EnableFeignClients 注解
            1.注解@EnableFeignClients告诉框架扫描所有使用注解@FeignClient定义的feign客户端。它又通过注解@Import导入了类FeignClientsRegistrar( feign客户端注册器)
            2.FeignClientsRegistrar : feign客户端注册器
            3.FeignClientsRegistrar实现了接口 ImportBeanDefinitionRegistrar。而ImportBeanDefinitionRegistrar的设计目的，就是被某个实现类实现，
                配合使用@Configuration注解的使用者配置类，在配置类被处理时，用于额外注册一部分bean定义

        3.编写业务逻辑接口并添加注解：@FeignClient(value = "CLOUD-PAYMENT-SERVICE"),
            这个接口直接复制provider的Controller方法完美。因为其整合了SpringMVC
        4.编写客户端Controller，调用上面的接口返回。

    OpenFeign 超时控制：需要服务提供方与调用方双方约定时间
        openFeign - ribbon 的调用，客户端一般默认等待1秒钟，超过这个时间得不到服务端返回结果，就会超时报错

        #设置feign客户端超时时间，openFeign默认支持 ribbon
        yml如下
            ribbon:
              #指的是建立连接所用时间，适用于网络状况正常情况下，两端连接所用时间
              ReadTimeout: 5000
              #指建立连接后从服务器读取到可用资源所用时间
              ConnectTimeout: 5000

    OpenFeign 日志打印功能：
           我们可以通过配置来调用日志级别，从而了解Feign 中 HTTP 请求细节
            日志级别：
                NONE：   默认不显示任何日志
                BASIC：  仅记录请求方法、URL、响应状态码及执行时间
                HEADERS：除了BASIC中定义的信息外，还有请求和响应的头信息
                FULL：   除了HEADERS外，还有请求和响应的正文及元数据

            功能使用：
                1.配置日志Bean
                    Logger.Level.FULL; //最全日志
                2.YML文件配置开启日志Feign客户端



Hystrix断路器：(消费端、服务端都可以使用，一般是放在客户端)
    分布式系统面临的问题：复杂的分布式系统的应用有数十个依赖关系，每个依赖关系在某些时候将不可避免的失败。
    Hystrix是一个用于处理分布式系统的 延迟 和 容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，
        比如超时、异常等。Hystrix能够保证在一个依赖出现问题，不会导致整体服务失败，避免级联故障，以提高
        分布式系统的弹性。
    通过断路器的故障监控，向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待
        或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了
        故障在分布式系统中蔓延，乃至雪崩。

    能干嘛：
        服务降级 fallback
            调用失败时，向调用方返回一个符合预期的、可处理的备选响应。
            发生条件： 程序运行异常、超时、服务熔断触发服务降级、线程池/信号量打满
        服务熔断 break
            达到最大访问量时，直接拒绝访问；然后调用服务降级的方法，并返回友好提示
        服务限流 flowLimit
            秒杀高并发等操作，排队，有序进行
        接近实时监控

    解决要求：
        8001超时导致服务器变慢：      超时，调用方80不再等待，必须有服务降级
        8001出错(宕机或程序报错):     出错，调用方80要有兜底，必须有服务降级
        8001提供服务OK：             调用方80自己故障或者有自我要求(自己等待时间小于服务提供者处理时间)，自己处理降级

    服务降级：
        服务提供方：
            一般在service层实现类的方法上注解 @HystrixCommand
            主启动类激活： @EnableCircuitBreaker (开启断路器，也支持服务降级)
            设置自身调用超时时间的峰值，峰值内可以正常运行；超过了需要有兜底的方法处理，作服务降级fallback
                @HystrixCommand(fallbackMethod = "paymentInfo_TimeOutHandler" ,commandProperties = {
                        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds",value = "3000")
                })
            它会单独使用HystrixTimer 线程池分配线程执行 服务降级fallback方法
            当服务不可用、超时 都是使用兜底方案paymentInfo_TimeOutHandler

        服务消费方：
            1.启动类 @EnableHystrix (开启服务降级熔断器，@EnableCircuitBreaker 的升级版?)
            2.业务类 一般在Controller层接口方法上注解 @HystrixCommand
            3.yml要开启feign:hystrix:enabled: true (激活hystrix服务降级对Feign的支持)

        现有问题：每个业务方法对应一个兜底方法，代码膨胀。那么需要统一fallbackMethod和自定义fallbackMethod分开
            膨胀(Controller层)：
                1.Controller类上注解 @DefaultProperties(defaultFallback="xxx")
                2.Controller层接口方法注解@HystrixCommand，如果@HystrixCommand指定了fallbackMethod就用指定的兜底方法，
                    否则使用@DefaultProperties(defaultFallback="xxx")指定的默认兜底方法

            解耦(openFeign接口系列)：
                1.只需要为客户端@FeignClient注解定义的接口添加一个服务降级处理的实现类，即可实现解耦,这个实现类需要扫描到spring容器；
                    前提是yml要开启feign:hystrix:enabled: true (激活hystrix服务降级对Feign的支持)
                2.例如 @FeignClient(value = "CLOUD-PROVIDER-HYSTRIX-SERVICE", fallback = PaymentFallbackService.class)

    服务熔断CircuitBreaker：
        1.熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务出错不可用或者响应时间太长，会进行服务的降级；
            进而熔断该节点微服务的调用，快速返回错误的响应信息。
        2.当检测到该节点微服务调用响应正常后，恢复调用链路(最牛逼的)。服务降级->进而熔断->恢复调用链路
        3.在Spring Cloud框架里，熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的情况，当失败的调用到一定阈值，
            缺省是：10秒内超过20次调用失败率超过50%，就会启动熔断机制。一段时间后(缺省是5秒)断路器进入半开状态，会让
            其中一个请求进行转发，如果成功，断路器会关闭；若失败，继续开启，重复之前。熔断机制的注解也是@HystrixCommand
        4.例子
            1.参数来自 com.netflix.hystrix.HystrixCommandProperties ，配置方式来自官方文档
            2.主启动类添加@EnableCircuitBreaker
            @HystrixCommand(fallbackMethod = "paymentCircuitBreaker_fallback", commandProperties = {
                    @HystrixProperty(name = "circuitBreaker.enabled", value = "true"), //断路器开启
                    @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"), //请求次数
                    @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "10000"),//时间窗口期
                    @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50") //失败率达到多少后跳闸
            })


    服务限流：高级篇讲解alibaba的Sentinel

    服务监控Hystrix Dashboard(接近实时监控，老系统会用<基本淘汰>，新系统基本用alibaba sentinel)
        1.Hystrix提供了准实时的调用监控，会持续记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形化展示给用户。
        Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring cloud也提供了Hystrix Dashboard
        的整合，对监控内容转化成可视化界面。
        2.创建项目：
            1.cloud-consumer-hystrix-dashboard9001
            2.添加依赖spring-cloud-starter-netflix-hystrix-dashboard
            3.主启动类@EnableHystrixDashboard
            4.9001监控首页 http://localhost:9001/hystrix
            5.所有provider微服务提供方(8001/8002..)都需要添加依赖spring-boot-starter-actuator,开启@EnableCircuitBreaker，才支持被9001监控
                provider微服务提供方被监控配置：
                    由于springcloud的坑，主启动类需要修改Bean：ServletRegistrationBean，注入HystrixMetricsStreamServlet，
                        添加addUrlMappings("/hystrix.stream")，具体看启动类
            6.9001监控首页 输入框填入你想监控的服务地址，如：http://localhost:8001/hystrix.stream ，Delay 2000, Title CLOUD-PROVIDER-HYSTRIX-SERVICE



在SpringCloud Gateway新一代服务网关(zuul路由网关已过时)
    1.Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能，如：熔断、限流、重试等。
    2.SpringCloud Gateway是原zuul1.x版的替代，Gateway是在Spring生态系统之上构建的API网关服务，基于Spring5、SpringBoot2和Project Reactor等技术。
    3.在Spring Cloud2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，任然还是使用Zuul 1.X非Reactor模式的老版本。
        而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的
        Reactor-netty响应式编程组建，底层通信框架Netty.
    4.SpringCloud Gateway的目标提供统一的路由方式，且基于Filter链的方式提供了网关基本功能，如：安全，监控/指标，限流

    作用：
        1.反向代理
        2.鉴权
        3.流量控制
        4.熔断
        5.日志监控

    特点：基于Spring5、SpringBoot2和Project Reactor等技术，使用非阻塞API
        1.动态路由：能够匹配任何请求属性
        2.可以对路由指定Predicate(断言)和Filter(过滤器)
        3.集成Hystrix的断路器功能
        4.集成SpringCloud服务发现功能
        5.易于编写的Predicate(断言)和Filter(过滤器)
        6.请求限流功能
        7.支持路径重写

    与Zuul的区别：
        1.在SpringCloud Finchley正式版之前，SpringCloud推荐使用Netflix的Zuul网关
        2.Zuul 1.x 是一个基于阻塞I/O的 API Gateway
        3.Zuul 1.x 基于Servlet2.5使用阻塞架构，它不支持任何长连接(如WebSocket)，Zuul 的设计模式和Nginx较像，每次I/O操作
            都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身
            有第一次加载较慢的情况，使得Zuul的性能相对较差
        4.Zuul 2.X 理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前没有整合，Zuul 2.x的性能较Zuul 1.x有较大
            提升。在性能方面，根据官方提供的基准测试，SpringCloud Gateway的RPS(每秒请求数)是Zuul的1.6倍
        5.SpringCloud Gateway 还支持WebSocket

    Spring WebFlux：
        1.传统的Web框架，比如说：struts2，springmvc 等都是基于Servlet API与Servlet 容器基础之上运行的。但是在Servlet3.1
            之后有了异步非阻塞的支持。而WebFlux时一个典型非阻塞异步框架，它的核心是基于Reactor的相关API实现的。相对于传统的
            Web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程。
        2.Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞
            的，并且基于Reactor来实现响应式流规范。

    三大核心概念：
        1.Route(路由) ：   路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由
        2.Predicate(断言)：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容(如请求头或
            请求参数)，如果请求与断言相匹配则进行路由。
        3.Filter(过滤)：   指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。

    工作原理：路由转发+执行过滤器链
        1.客户端向Spring Cloud Gateway发出请求，然后在Gateway Handler Mapping 中找到与请求相匹配的路由，
            将其发送到Gateway Web Handler
        2.Web Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。
        3.过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前("pre")或之后("post")执行业务逻辑。
            Filter在 pre 类型的过滤器可以做 参数校验、权限校验、流量监控、日志输出、协议转换等；
            在 post 类型的过滤器中可以做响应内容、响应头的修改，日志输出，流量监控等

    使用：
        1.我们目前不想暴露8001端口，希望在8001外面套一层9527,gateway项目配置如下yml
            spring:
              application:
                name: cloud-gateway
              #Gateway配置
              cloud:
                gateway:
                  routes:
                    - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/get/**    #断言，路径相匹配的进行路由

                    - id: payment_routh2           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                      uri: http://localhost:8001  #匹配后提供服务的路由地址
                      predicates:
                        - Path=/payment/lb/**    #断言，路径相匹配的进行路由
            eureka:
              client:
                ...

        2.依赖
            spring-cloud-starter-gateway
            spring-cloud-starter-netflix-eureka-client
            不依赖 spring-boot-starter-web、spring-boot-starter-actuator，否则无法启动
            启动后 http://localhost:9527/payment/get/3 也能获取数据

        3.Gateway网关路由有两种配置方式：
            1.如1所示，在yml中配置 (推荐)
            2.代码中注入RouteLocator的Bean

        4.通过微服务名实现动态路由
            1.默认情况下Gateway会根据注册中心的服务列表，以注册中心上微服务名为路径，创建动态路由进行转发，
                从而实现动态路由的功能
            2.yml修改
                1.需要注意的是uri的协议是lb，表示启用Gateway的负载均衡功能。
                2.lb://serviceName 是spring cloud Gateway在微服务中自动为我们创建的负载均衡uri。
                    spring:
                      application:
                        name: cloud-gateway
                      #Gateway配置
                      cloud:
                        gateway:
                          discovery:
                            locator:
                              enabled: true # 开启从注册中心动态创建路由的功能，利用微服务名进行路由
                          routes:
                            - id: payment_routh1           #路由ID，没有固定规则，但要求唯一，建议配合服务名命名
                              uri: lb://cloud-payment-service  #匹配后提供服务的路由地址 （动态路由）
                              predicates:
                                - Path=/payment/get/**    #断言，路径相匹配的进行路由

        5.Predicate的使用
            1.理论
                1.spring cloud Gateway 将路由匹配作为 Spring WebFlux HandlerMapping基础架构的一部分。
                2.spring cloud Gateway 包括许多内置的Route Predicate工厂，所有这些Predicate都与HTTP请求的不同属性匹配。
                    多个Route Predicate工厂可以进行组合
                3.spring cloud Gateway 创建Route对象时，使用RoutePredicateFactory创建Predicate对象，Predicate对象可以
                    赋值给Route。
                4.所有这些谓词都匹配HTTP请求的不同属性，多种谓词工厂可以组合，并通过逻辑and
            2.共13种路由断言方式
                [After][Before][Between][Cookie][Header][Host][Method][Path][Query]
                [ReadBodyPredicateFactory][RemoteAddr][Weight][CloudFoundryRouteService]
                1. - Path=/payment/lb/**    #断言，路径相匹配的进行路由
                2. - After=2020-09-15T15:07:39.177+08:00[Asia/Shanghai] 时间格式是美国格式，需要通过代码生成中国时间的美国格式 ZonedDateTime.now()
                3. - Cookie=username,lzq
                4. - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式
                5. - Method=GET
            3.jmeter，postman，curl 测试
                curl测试：底层get/post命令
                curl http://localhost:9527/payment/lb
                curl http://localhost:9527/payment/lb --cookie "username=lzq"
                curl http://localhost:9527/payment/lb -H "X-Request-Id:1234"
                    - Header=X-Request-Id, \d+  #请求头要有X-Request-Id属性并且值为整数的正则表达式

        6.Filter(过滤)：指spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。
            1.路由过滤器可以用于修改进入的HTTP请求和返回的HTTP响应，路由过滤器只能指定路由进行使用。
            2.spring cloud Gateway 内置了多种路由过滤器，他们都由GatewayFilter的工厂类来产生
            3.生命周期：pre（路由前）、post（路由后）
            4.种类：GatewayFilter（单一的31个）、GlobalFilter（全局的10个）
            5.常用过滤器 AddRequestParameter   yml 配置(简单不是重点，重点是全局的自定义过滤器)
                filters:
                    - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头上加一对请求头，名称为X-Request-Id值为1024
            6.自定义全局过滤器（推荐使用）
                1.主要是实现GlobalFilter、Ordered 两个接口
                2.作用：全局日志记录、统一网关鉴权。。。


SpringCloud Config 分布式配置中心
    1.分布式系统面临的配置问题：
        由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的，一处修改，处处生效。
        SpringCloud 提供了ConfigService来解决这个问题。
    2.SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持(配置服务器为 各个不同微服务应用 的所有环境提供了
        一个 中心化的外部配置)
    3.SpringCloud Config分为服务端和客户端<就是provider A/B/C>两部分
        服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息
            等访问接口。
        客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息，
            配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可以通过git客户端工具来方便的
            管理和访问配置内容。
    4.作用：
        1.集中管理配置文件
        2.分环境部署
        3.运行时动态调整配置
        4.自动化加载最新的配置
        5.将配置信息以REST接口的形式暴露

    5.使用
        1.服务端：
            1.git 地址 https://github.com/736465175/springcloud-config.git  账户 736465175  密码 lzq19910214
            2. 多个环境配置文件，保存格式必须UTF-8，如果需要修改，命名 git add , git commit -m "init yml" ,git push origin master
            3.依赖
                spring-cloud-config-server ，spring-cloud-starter-netflix-eureka-client
            4.yml配置
                spring:
                  application:
                    name: cloud-config-center
                  cloud:
                    config:
                      server:
                        git:
                          uri: https://github.com/736465175/springcloud-config.git #github上面的git仓库名
                          #搜索目录
                          search-paths:
                            - springcloud-config
                          #读取分支
                      label: master
            5.主启动类添加 @EnableConfigServer
            6.hosts修改 增加映射 127.0.0.1 config-3344.com
                C:\Windows\System32\drivers\etc
            7.启动项目（先启动Eureka） 访问 http://config-3344.com:3344/master/config-dev.yml
                成功读取到 github上读取内容
            8.严格配置读取规则
                1./{label(分支)}/{application(文件名,可以是微服务名称)}-{profile(后缀)}.yml
                    master分支：   http://config-3344.com:3344/master/config-dev.yml
                    dev   分支：   http://config-3344.com:3344/dev/config-dev.yml

        2.客户端：
            1.依赖：spring-cloud-starter-config，spring-cloud-starter-netflix-eureka-client
                    spring-boot-starter-web(缺少无法启动，也不报错！！！)
            2.bootstrap.yml
                说明：
                    1.application.yml 是用户级的资源配置项，bootstrap.yml是系统级的，优先级更高。
                    2.Spring Cloud会创建一个"BootStrap Context"，作为Spring应用的Application Context的
                        父上下文。初始化的时候，BootStrap Context负责从外部源加载配置属性并解析配置。这两
                        上下文共享一个外部获取的'Environment'。
                    3.'BootStrap'属性优先级高，默认情况下，它们不会被本地配置覆盖，'BootStrap Context'和
                        'Application Context' 有着不同的约定，所以新增了一个'bootstrap.yml'文件，保证
                        'BootStrap Context' 和'Application Context'配置分离。
                    4.需要将Client端的application.yml修改为 bootstrap.yml。（热部署修改bootstrap.yml 失效了？？？）

        3.分布式配置的动态刷新问题：
            Linux运维修改GitHub上的配置文件内容，刷新3344发现ConfigServer配置中心立即响应(立即更新)；
                刷新3355发现ConfigClient没有任何响应(没有更新到最新的配置)，除非自己重启或者重新加载。

        4.Config客户端动态刷新(手动版)
            1.修改3355模块，引入pom   spring-boot-starter-actuator (除网关Gateway不需要，其他module都需要)
            2.修改YML，暴露监控接口
                  #暴露监控端点
                  management:
                    endpoints:
                      web:
                        exposure:
                          include: "*"  #统一写法
            3.业务类Controller 类上添加@RefreshScope
            4.还需要运维人员发送Post请求刷新3355，才能成功实现3355刷新到最新配置(需要每个微服务执行以下Post请求)
                curl -X POST http://localhost:3355/actuator/refresh  激活3355加载最新的ConfigServer配置

        5.Config客户端动态刷新(自动版)
            广播，一次通知，处处生效；大范围的自动刷新 ；所以需要消息总线SpringCloud Bus来帮忙


SpringCloud Bus 消息总线
    1.它是SpringCloud Config的绝配，一般是一起使用，实现配置动态刷新。
    2.SpringCloud Bus 是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息
        中间件的功能；目前支持两种消息代理，RabbitMQ 和 Kafka
    3.SpringCloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态变更、事件推送，也可以当做
        微服务间的通信通道。

    4.总线：
        在微服务架构系统中，通常会使用 轻量级的消息代理 来构建一个 共同的消息主题，并让系统中所有微服务实例都连接上来。
            由于 该主题中产生的消息会被所有实例监听和消费，所以称他为消息总线。 在总线上的各个实例，都可以方便的广播
            一些需要让其他连接在该主题上的实例都知道的消息。
    5.基本原理：
        ConfigClient实例都监听MQ中同一个topic(默认是 springCloudBus)。当一个服务刷新数据的时候，它会把这个消息放
            入到Topic中，这样其他监听同一个Topic的服务就能得到通知，然后去更新自身的配置。

    6.RabbitMQ环境配置：
        1.安装Erlang      http://erlang.org/download/otp_win64_21.3.exe
        2.安装RabbitMQ    https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/
        3.进入RabbitMQ安装目录下的sbin目录,输入以下命令启动管理功能
            1.进入 D:\Program Files (x86)\RabbitMQ_3.7.14\rabbitmq_server-3.7.14\sbin 目录
            2.cmd 输入命令： rabbitmq-plugins enable rabbitmq_management 安装可视化插件
            3.Windows开始下标可以看到插件,点击start启动MQ
        4.访问地址查看是否安装成功
            http://localhost:15672/
        5.输入账号密码登陆guest/guest

    7.SpringCloud Bus动态刷新全局广播
        1.RabbitMQ环境OK
        2.演示广播效果，增加复杂度，以3355为模板新建一个3366
        3.设计思想
            1.利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置。
            2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置。(推荐)
            3.方式二更合适，方式一不合适原因：
                1.因为微服务本身是业务模块，它本身不应该承担刷新配置的职责。
                2.破坏了微服务各节点的对等性
                3.有一定局限性，因网络、迁移等原因受到制约
        4.给cloud-config-center3344配置中心服务端 添加消息总线支持
            1.pom引入spring-boot-starter-bus-amqp 添加消息总线RabbitMQ支持,整合bus和RabbitMQ
                spring-cloud-config-server包含了 springboot-starter  actuator/ web,不用再引入这两包
            2.yml修改， 增加
                #RabbitMQ相关配置
                spring
                  rabbitmq:
                    host: localhost
                    port: 5672
                    username: guest
                    password: guest

                #rabbitmq相关配置，暴露bus刷新配置的端点
                management:
                  endpoints:
                    web:
                      exposure:
                        include: "bus-refresh"

        5.给cloud-config-client3355/3366客户端添加消息总线支持
            1.pom引入spring-boot-starter-bus-amqp 添加消息总线RabbitMQ支持,整合bus和RabbitMQ
            2.yml修改
                #RabbitMQ相关配置
                spring
                  rabbitmq:
                    host: localhost
                    port: 5672
                    username: guest
                    password: guest
                #暴露监控端点
                management:
                    endpoints:
                      web:
                        exposure:
                          include: "*"  #统一写法
        6.测试
            1.全部启动后查看所有配置，修改github上的配置，在查看一下所有服务读取的配置信息
            2.发送POST请求给配置中心：
                curl -X POST http://localhost:3344/actuator/bus-refresh
                激活3344加载最新的git配置，并广播给所有客户端刷新到最新配置

    8.SpringCloud Bus动态刷新定点通知
        1.指定具体某一个实例生效而不是全部
        2.公式：
            发送POST请求给配置中心
                curl -X POST http://localhost:3344/actuator/bus-refresh/{destination}
            通过destination参数类指定需要更新配置的服务或实例，destination=Eureka注册中心上注册的服务名(小写):服务端口
                例如：curl -X POST http://localhost:3344/actuator/bus-refresh/cloud-config-client:3355


SpringCloud Stream 消息驱动：
    1.为什么引入：一种新技术，让我们不再关注具体MQ的细节，我们只需要用一种适配绑定的方式，自动在各种MQ内切换。
    2.是什么：
        1.屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型。
        2.官方定义：是一个构建消息驱动微服务的框架。应用程序通过inputs或者outputs来与SpringCloud Stream中的binder(绑定器)对象交互。
            通过我们配置来binding，而SpringCloud Stream的binder对象负责与消息中间件交互。我们只需要清楚如何与SpringCloud Stream
            交互就可以方便的使用消息驱动的方式。
        3.通过使用Spring Integration 来连接消息代理中间件以实现消息事件驱动。SpringCloud Stream为这些供应商的消息中间件产品提供了
            个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。目前仅支持RabbitMQ和Kafka.

    3.stream统一底层差异
        1.通过定义绑定器作为中间层，完美的实现了 应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得
            应用程序不需要再考虑各种不同消息中间件实现。
        2.通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离。
        3.Binder ：input(对应于消费者)，output(对应于生产者)
        4.Stream中的消息通信方式遵循了发布-订阅模式：
            主要是 Topic主题进行广播，RabbitMQ就是Exchange、Kafka中就是Topic

    4.SpringCloud Stream 标准流程套路
        消息生产者->业务逻辑->{SpringCloud Stream ： Source  Channel  Binder} ->MQ组件|
        消息消费者->业务逻辑->{SpringCloud Stream ： Sink  Channel  Binder}        <- |
        说明：
            Binder： 连接中间件，屏蔽差异，应用与消息中间件之间的封装。
            Channel: 通道，是Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介
            Source/Sink：输出、输入

    5.编码API和常用注解
        @input          注解标识输入通道，通过该输入通道接收到的消息进入应用程序
        @output         注解标识输出通道，发布的消息将通过该通道离开应用程序
        @StreamListener 监听队列，用于消费者的队列的消息接收
        @EnableBinding  指信道channel和exchange绑定在一起

    6案例说明
        1.新建三个子模块
            1.cloud-stream-rabbitmq-provider8801 生产者
                1.pom引入 spring-cloud-starter-stream-rabbit，spring-cloud-starter-netflix-eureka-client
                    spring-boot-starter-web，spring-boot-starter-actuator
                2.yml配置
                    spring:
                      application:
                        name: cloud-stream-provider
                      cloud:
                        stream:
                          binders: #在此处配置要绑定的rabbitMq的服务信息
                            defaultRabbit:  #表示定义的名称，用于binding整合
                              type: rabbit  #消息组件类型
                              environment:  #设置RabbitMQ的相关的环境配置
                                spring:
                                  #RabbitMQ相关配置,15672是web管理端口
                                  rabbitmq:
                                    host: localhost
                                    port: 5672
                                    username: guest
                                    password: guest
                          bindings: #服务的整合处理
                            output: #这个名字是一个通道的名称，表示是生产者
                              destination: studyExchange  #表示要使用的Exchange名称定义(主题)
                              content-type: application/json #设置消息类型，本次为json，文本则用"text/plain"
                              binder: defaultRabbit #设置要绑定的消息服务的具体设置
                3.主启动类只需要 @SpringBootApplication，开启Eureka注册服务功能H版默认通过配置即可
                4.消息推送接口实现类(MessageProviderImpl)
                    1.类上注释 @EnableBinding(Source.class) ：
                        定义消息的推送管道，cloud stream 架构中提到，这里就是这样编码
                        //@Service 类上不需要该注释，因为这里的service是和Stream-RabbitMQ框架关联的，是配置层(@Configuration)，不是服务层了
                    2.该类注入org.springframework.messaging.MessageChannel output属性
                        boolean sendResult = output.send(MessageBuilder.withPayload(serial).build());
                        //springcloud stream官网告诉我们这样写

            2.cloud-stream-rabbitmq-consumer8802/8803 消费者
                1.pom 引入 同 cloud-stream-rabbitmq-provider8801相同
                2.yml配置 基本同cloud-stream-rabbitmq-provider8801相同，只需要将bindings.output修改为bindings.input表示消息消费者
                3.主启动类只需要 @SpringBootApplication，开启Eureka注册服务功能H版默认通过配置即可
                4.监听器 ReceiveMessageListenerController类，已经不是HTTP接口形式了，只负责监听定义好的目标主题destination: studyExchange(也可以理解订阅)
                    该类注解 @EnableBinding(Sink.class)即可，
                    其次编写方法
                       @StreamListener(Sink.INPUT)
                       public void input(Message<String> message){message.getPayload();...} 即可接收消息

            3.分组消费与持久化
                1.8802,8803运行后有两个问题：http://localhost:8801/sendMessage，出现重复消费问题。
                    解决：在SpringCloud Stream中处于同一个组(group)的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次。
                        不同的组才能全面消费(重复消费)，由于默认情况下8802/8803都是用默认分组(系统分配流水号)，导致它们是不同的组，
                        消息被重复消费了。
                2.查看服务是否是同一个组：
                    登陆RabbitMQ  http://localhost:15672/  选择Exchanges->studyExchange(队列名点进去)->This exchange看到两个不同的组名
                        studyExchange.anonymous.BxP_LB_nRNGRuCVqwgrHHA  8802(流水号就是组名)
                        studyExchange.anonymous.kA3OcZqBQ6m0Wkxj4fcvSQ  8803
                3.微服务消费者如何实现分组
                    1.自定义配置分组(先将微服务分配为两个不同的自定义组)
                        1.yml 8802修改,只需要添加bindings.input.group: lizhiqiangA
                          .....
                          bindings: #服务的整合处理
                            input: #这个名字是一个通道的名称，表示是消费者
                              destination: studyExchange  #表示要是用的Exchange名称定义，队列名称
                              content-type: application/json #设置消息类型，本次为json，文本则用"text/plain"
                              binder: defaultRabbit #设置要绑定的消息服务的具体设置
                              group: lizhiqiangA

                    2.自定义配置将微服务分为同一个组，解决重复消费问题
                        8802/8803 bindings.input.group: lizhiqiangA group取名一样

                4.持久化：有了分组属性，就具备了持久化！！！


SpringCloud Sleuth 分布式请求链路跟踪
    1.在微服务框架中，一个由 客户端发起的请求在后端系统中会经过多个不同的微服务节点调用来协同产生最后的请求结果，每一个前段
        请求都会形成一条复杂的分布式服务调用链路，链路中的任何一个环节出现高延时或者错误都会引起整个请求的最后失败。
    2.Sleuth 提供了一套完整的服务跟踪的解决方案，在分布式系统中提供追踪解决方案并且兼容支持了zipkin。
        Sleuth管监控(收集整理)，zipkin管展现。
    3.搭建链路监控步骤
        1.zipkin下载，SpringCloud从F版起已不需要自己构建Zipkin Server了，只需要调用jar包即可。
            1.下载地址 https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/
            2.运行jar， java -jar  zipkin-server-2.12.9-exec.jar
            3.运行控制台 http://localhost:9411/zipkin/
            4.术语：
                1.完整的调用链路：表示一请求链路，一条链路通过Trace id(微服务名称)唯一标识，Span表示发起的请求信息，各span通过parent id关联起来
                2.Trance类似于树结构的Span集合，表示一条调用链路，存在唯一标识
                3.Span表示调用链路来源，通俗的理解span就是一次请求
        2.服务提供者
            1.使用cloud-provider-payment8001
            2.pom添加依赖 spring-cloud-starter-zipkin 包含了sleuth+zipkin
            3.yml修改 添加
                spring:
                  application:
                    name: cloud-payment-service
                  zipkin:
                    #监控数据图表打到zipkin dashboard 上
                    base-url: http://localhost:9411
                  sleuth:
                    sampler:
                      #采样率介于0到1之间，1表示全部采样
                      probability: 1
            4.业务类PaymentController增加测试方法
        3.服务消费者
            同上
        4.调用服务后，打开浏览器访问http://localhost:9411


SpringCloud Alibaba 入门简介
    1.SpringCloud Netflix项目进入维护模式，是从G版开始的；将模块设置于维护模式，意味着SpringCloud团队将不会再向模块添加新功能。
        只会修复阻塞级别bug。
    2.alibaba 推出的 Dubbo，后面被SpringCloud杀过来而取代，SpringCloud后面出问题了，SpringCloud Alibaba 杀过来了
        SpringCloud Alibaba 目标是一切在云端(阿里云，商业推广)，SpringCloud也希望alibaba加入
    3.2018-10-31 SpringCloud Alibaba 0.2.0正式入驻了 SpringCloud官方孵化器，并在Maven中央库发布了第一个版本
    4.作用：
        1.服务限流降级：默认支持Servlet、Feign、RestTemplate、Dubbo和 RocketMQ限流降级功能接入，可以在运行时通过控制台实时
            修改限流降级规则，还支持查看限流降级Metrics监控
        2.服务注册与发现：适配SpringCloud服务注册与发现标准，默认集成了Ribbon的支持。
        3.分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新
        4.消息驱动能力：基于SpringCloud Stream为微服务应用构建消息驱动能力
        5.阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意
            类型数据。
        6.分布式任务调度：提供秒级、精准、高可靠、高可用的定时(基于Con表达式)任务调度服务。同时提供分布式的任务执行模型，如网
            格任务。网格任务支持海量子任务均匀分配到所有Worker(Schedulerx-client)上执行
    5.怎么玩
        1.Sentinel(核心知识)：阿里巴巴开源产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。
        2.Nacos(核心知识): 阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。
        3.RocketMQ： Apache RocketMQ 基于Java的高性能、高吞吐量的分布式消息和流计算平台
        4.Dubbo： Apache Dubbo是一款高性能java RPC框架
        5.Seata(核心知识): 阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案
        6.Alibaba Cloud OSS： 阿里云对象存储服务(Object Storage Service)，是阿里云提供海量、安全、低成本、高可靠的云存储服务。
        7.Alibaba Cloud SchedulerX: 阿里中间件团队开发的一款分布式任务调度产品，支持周期性的任务与固定时间点触发任务。
        8.中文官方文档：http://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md


SpringCloud Alibaba Nacos 服务注册和配置中心
    1.Nacos = Dynamic(动态) Naming and Configuration Service  == Eureka + Config + Bus
        一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台.
    2.下载和文档
        1.https://nacos.io/zh-cn/ 文档
        2.https://github.com/alibaba/nacos/releases
    3.Nacos  AP模型，支持控制台管理；据说Nacos在阿里巴巴内部有超过10万的实例运行，经得起考验。
    4.安装运行Nacos
        1.本地Java8 + Maven环境
        2.解压安装包，直接运行bin目录下startup.cmd 或者 cmd下独立运行startup.cmd -m standalone
        3.运行成功后 访问 http://localhost:8848/nacos  密码nacos/nacos

    5.Nacos作为注册中心
        1.基于Nacos的服务提供者
            1.新建module cloudalibaba-provider-payment9001
            2.pom
                1.父pom
                          <dependency>
                            <groupId>com.alibaba.cloud</groupId>
                            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                            <version>2.1.0.RELEASE</version>
                            <type>pom</type>
                            <scope>import</scope>
                          </dependency>
                2.本模块pom
                     <dependency>
                         <groupId>com.alibaba.cloud</groupId>
                         <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                     </dependency>
            3.yml
                 spring.application.name=nacos-payment-provider
                 server.port=9001
                 spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
                 #监控暴露
                 management.endpoints.web.exposure.include=*
                    Spring boot actuator端点启用和暴露
                        1.在YAML中有特殊的含义，所以如果想使用include或者exclude包含所有的端点时要加上双引号
                        2.* 可以用来表示所有的端点，例如，通过HTTP公开所有的端点，除了env和beans端点，使用如下的属性

            4.主启动类
                 @SpringBootApplication
                 @EnableDiscoveryClient
            5.业务类略
            6.服务启动后，通过http://localhost:8848/nacos 查看服务列表，能看到服务注册OK
            7.重复新建9002演示负载均衡,alibaba-nacos-discovery 天生整合了Netflix ribbon

        2.基于Nacos的服务消费者
            1.新建module cloudalibaba-consumer-order8000
            2.pom
                1.父pom
                          <dependency>
                            <groupId>com.alibaba.cloud</groupId>
                            <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                            <version>2.1.0.RELEASE</version>
                            <type>pom</type>
                            <scope>import</scope>
                          </dependency>
                2.本模块pom
                     <dependency>
                         <groupId>com.alibaba.cloud</groupId>
                         <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
                     </dependency>
            3.yml
                 server:
                   port: 8000
                 spring:
                   application:
                     name: nacos-order-consumer
                   cloud:
                     nacos:
                       discovery:
                         server-addr: 127.0.0.1:8848
                 #自定义配置，消费者访问微服务名称
                 service-url:
                   nacos-user-service: http://nacos-payment-provider
            4.主启动类
                 @SpringBootApplication
                 @EnableDiscoveryClient
            5.业务类略，同之前讲解ribbon一样
                配置类 ApplicationContextConfig
                @Bean
                @LoadBalanced
                public RestTemplate getRestTemplate(){
                    return new RestTemplate();
                }
    6.各种注册中心比较
        1.Nacos  Java   AP/CP模型可切换，支持控制台管理（参考笔记抓图）
        2.C是所有节点在同一时间看到的数据是一致的，而A的定义是所有的请求都要收到响应
        3.如何选择使用哪种模式
            1.如果不需要存储服务级别的信息且服务实例是通过nacos-client注册，并能够保持心跳上报，那么就可以选择AP模式。
                当前主流的服务如SpringCloud 和Dubbo服务，都适用于AP模式。AP模式为了服务的可用性而减弱了一致性，因此
                AP模式下只支持注册临时的实例。
            2.如果需要在服务级别编辑或者存储配置信息，那么CP是必须的，K8S服务和DNS服务则适合CP模式。
                CP模式下则支持注册持久化实例，此时则是以Raft协议为集群运行模式，该模式下注册实例之前必须先注册服务，如果
                服务不存在，则会返回错误。
            3.切换Nacos注册中心CP模式
                curl -X PUT '$NACOS_SERVER:8848/nacos/v1/ns/operator/switches?entry=serverMode&value=CP'

    7.Nacos作为服务配置中心
        1.基础配置
            1.cloudalibaba-config-nacos-client3377
            2.pom依赖
                spring-cloud-starter-alibaba-nacos-config
                spring-cloud-starter-alibaba-nacos-discovery
                spring-boot-starter-web
                spring-boot-starter-actuator
            3.yml配置
                1.需要application.yml(设置私有配置) 和 bootstrap.yml(设置全局配置) 两个配置文件
                2.因为Nacos同SpringCloud-config一样，在项目初始化时，要先保证从配置中心拉取配置，拉取后才保证项目正常启动。
                3.bootstrap.yml
                    server:
                      port: 3377
                    spring:
                      application:
                        name: nacos-config-client
                      cloud:
                        nacos:
                          discovery:
                            server-addr: 127.0.0.1:8848 #nacos 服务注册中心地址
                          config:
                            server-addr: 127.0.0.1:8848
                            file-extension: yaml  #指定配置中心配置格式，properties是默认格式
                    # ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}
                4.application.yml
                    spring:
                      profiles:
                        active: dev  #表示开发环境
            4.业务类Controller层支持nacos动态刷新，添加注解
                @RefreshScope //通过SpringCloud 原生注解实现配置自动更新
            5.在nacos 中添加配置信息
                1.nacos配置规则
                    1.nacos中data id 的组成格式及与SpringBoot配置文件中的匹配规则
                    2.${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension}
                       dataid = nacos-config-client-dev.yaml
                    3.nacos配置中心新建文件 nacos-config-client-dev.yaml ，格式选择yaml , 默认分组DEFAULT_GROUP
            6.测试
                1.运行3377，调用接口查看配置信息：http://localhost:3377/config/info
                2.修改nacos配置中心上nacos-config-client-dev.yml内容，发现支持动态刷新

        2.分类配置
            1.多环境多项目管理
                1.通常一个系统有 dev test prod 三个环境，如何保证指定环境启动时服务能正确读到Nacos上相应环境的配置文件
                2.微服务子项目也有三个环境，如何配置管理
            2.nacos的图形化界面
                配置管理，命名空间
            3.namespace + Group + Data ID 三者关系？为什么这么设计？
                1.类似于Java里面的package名称和类名，最外层的namespace是可以用于区分部署环境的，Group 和 DataID逻辑上区分两个目标对象
                2.默认情况
                    Namespace=public ，命名空间主要是用来实现隔离
                    Group=DEFAULT_GROUP ，Group可以把不同的微服务划分到同一个分组里面去
                    默认Cluster = DEFAULT ，Cluster 是对指定微服务的一个虚拟划分
                        Service 就是微服务，Instance就是微服务的实例
            4.case三种方案加载配置
                1.DataID方案
                    1.常用：指定spring.profile.active和配置文件的DataID来使不同环境下读取不同的配置
                    2.默认空间+默认分组+新建dev 和test 两个DataID
                    3.通过config-nacos-client3377的 spring.profile.active属性就能进行多环境配置文件读取
                2.Group方案
                    1.通过Group实现环境区分
                        1.在nacos图形界面控制台上新建配置文件DataID，这里配置Group 为DEV_GROUP
                            1.nacos-config-client-info.yaml   DVE_GROUP
                            2.nacos-config-client-info.yaml   TEST_GROUP
                        2.bootstrap+application修改
                            1.bootstrap增加 group: TEST_GROUP
                                spring:
                                  application:
                                    name: nacos-config-client
                                  cloud:
                                    nacos:
                                      discovery:
                                        server-addr: 127.0.0.1:8848 #nacos 服务注册中心地址
                                      config:
                                        server-addr: 127.0.0.1:8848
                                        file-extension: yaml  #指定配置中心配置格式，properties是默认格式
                                        group: TEST_GROUP
                            2.application修改 spring.profile.active=info
                3.Namespace方案
                    1.新建dev/test 的Namespace
                        dev     12688ec5-c289-4af5-9657-6fe1da79df1a
                        test    b96a9124-618f-4d73-a70a-8496ed11843a
                    2.回到服务管理-服务列表查看
                    3.按照域名配置填写
                    4.yml
                        spring:
                          application:
                            name: nacos-config-client
                          cloud:
                            nacos:
                              discovery:
                                server-addr: 127.0.0.1:8848 #nacos 服务注册中心地址
                              config:
                                server-addr: 127.0.0.1:8848
                                file-extension: yaml  #指定配置中心配置格式，properties是默认格式
                                group: DEV_GROUP
                                namespace: 12688ec5-c289-4af5-9657-6fe1da79df1a
    8.nacos集群和持久化配置(重点)
        1.官方说明 https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html
            http://nacos.com:port/openAPI 域名 + VIP模式，可读性好，而且换ip方便，推荐模式
        2.默认Nacos使用嵌入式数据库(derby)实现数据的存储。所以如果启动多个默认配置下的nacos节点，数据存储是存在一致性问题的。
            为了解决这个问题，nacos采用了 集中式存储的方式来支持集群化部署，目前只支持MySQL的存储。
        3.nacos支持3种部署模式
            1.单机模式  ：用于测试和单机试用，也支持MySQL数据库存储
            2.集群模式  ：用于生产环境，确保高可用
            3.多集群模式：用于多数据中心场景
        2.nacos持久化配置解释
            1.默认Nacos使用嵌入式数据库(derby)实现数据的存储
            2.derby切换到MySQL数据库配置
                1.E:\java\tools\nacos-server-1.3.2\nacos\conf 目录下找到sql脚本 nacos-mysql.sql，数据库连接工具执行脚本
                2.E:\java\tools\nacos-server-1.3.2\nacos\conf 目录下找到application.properties
                    1.安装数据库，版本要求：5.6.5+
                    2.初始化mysql数据库，数据库初始化文件：nacos-mysql.sql
                    3.修改conf/application.properties文件，增加支持mysql数据源配置（目前只支持mysql），添加mysql数据源的url、用户名和密码。
                        spring.datasource.platform=mysql
                        db.num=1
                        db.url.0=jdbc:mysql://11.162.196.16:3306/nacos_devtest?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
                        db.user=nacos_devtest
                        db.password=youdontknow
        3.Linux版Nacos集群+MySQL生产环境配置
            1.预计需要 1个Nginx + 3个nacos注册中心 + 1个MySQL
            2.nacos下载Linux版
            3.集群配置步骤
                1.Linux服务器MySQL数据库配置
                2.application.properties配置
                3.Linux服务器上nacos的集群配置cluster.conf
                    1.复制 cluster.conf.example 成 cluster.conf
                    2.内容,表示3个是nacos集群节点，是一组的，这里的IP不能是127.0.0.1
                        192.168.1.107:3333
                        192.168.1.107:4444
                        192.168.1.107:5555
                4.编辑nacos的启动脚本startup.sh ，使它能够接收不同的启动端口
                    1.期望启动命令变成 ./startup.sh -port 3333  端口和上一步cluster.conf 配置一致
                    2.while getopts ":m:f:s:c:p:" opt -> while getopts ":m:f:s:c:p:port:" opt
                        port)
                           PORT=$OPTARG;;
                      nohup $JAVA ${JAVA_OPT} nacos.nacos >> ${BASE_DIR}/logs/start.out 2>&1 &  修改为
                      nohup $JAVA -Dserver.port=${PORT}  ${JAVA_OPT} nacos.nacos >> ${BASE_DIR}/logs/start.out 2>&1 &

                5.Nginx配置，它作为负载均衡器
                    1.修改Nginx配置文件 /usr/local/nginx/conf/nginx.conf
                    2.server listen 监控 1111端口，所有请求先通过1111访问，再通过location / 根目录配置分流。
                        分流完后，配置upstream，撇出上面上个nacos集群配置节点
                        upstream cluster{
                            server 127.0.0.1:3333;
                            server 127.0.0.1:4444;
                            server 127.0.0.1:5555;
                        }
                        server{
                            listen 1111;
                            server_name localhost;

                            location / {
                                proxy_pass http://cluster;
                            }
                        }
                    3.按照指定nginx.conf 启动 Nginx
                        1. cd /usr/local/nginx/sbin/
                        2. ./nginx -c /usr/local/nginx/conf/nginx.conf
            4.测试
                1.启动Nginx ，3台nacos ，测试通过Nginx访问nacos http://192.168.111.144:1111/nacos/#/login 登陆创建配置成功OK
                2.微服务启动能注册进nacos集群，并能读取配置，说明OK
                    1.通过spring.cloud.nacos.discovery.server-addr=192.168.111.144:1111(nginx listen 配置的IP+端口)
                        配置到连接nginx指定连接，然后由nginx转发给3333/4444/5555 随机一个注册微服务
            5.高可用小结，见笔记截图


SpringCloud Alibaba Sentinel 实现熔断与限流(哨兵)
    1.分布式系统的流量防卫兵 = Hystrix ,官方文档 https://github.com/alibaba/Sentinel/wiki/介绍
    2.Sentinel 具有以下特征
        1.丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）
            、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。
        2.完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的
            汇总运行情况。
        3.广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相
            应的依赖并进行简单的配置即可快速地接入 Sentinel。
        4.完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配
            动态数据源等。
    3.作用
        服务雪崩，服务降级，服务熔断，服务限流
    4.Sentinel 分为两个部分
        1.核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。
        2.控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。
    5.安装Sentinel控制台
        1.启动
            1.下载 sentinel-dashboard-1.7.1.jar，jdk8 + 8080端口环境
            2.命令 java -jar sentinel-dashboard-1.7.1.jar
        2.访问sentinel管理界面 http://localhost:8080  账号密码 sentinel 登陆成功后表示：降级、容错、监控、限流平台完成
    6.初始化演示工程
        1.启动nacos 8848 微服务注册/配置中心
        2.建module cloudalibaba-sentinel-service8401
            1.pom
                spring-cloud-starter-alibaba-nacos-discovery
                spring-cloud-starter-alibaba-sentinel
                spring-cloud-starter-openfeign
                spring-boot-starter-web
                spring-boot-starter-actuator
            2.yml
                server:
                  port: 8401
                spring:
                  application:
                    name: cloudalibaba-sentinel-service
                  cloud:
                    nacos:
                      discovery:
                        #nacos 服务注册中心地址
                        server-addr: 127.0.0.1:8848
                    sentinel:
                      transport:
                        #配置 sentinel dashboard 地址
                        dashboard: 127.0.0.1:8080
                        #默认8719端口，假如被占用会自动依次从8719+1扫描，直至找到未被占用的端口
                        port: 8719
                #暴露监控端点
                management:
                  endpoints:
                    web:
                      exposure:
                        include: '*'  #统一写法
            3.主启动类
                @SpringBootApplication
                @EnableDiscoveryClient
            4.业务类FlowLimitController
        3.启动 sentinel-dashboard 8080
        4.启动微服务8401,后查看Sentinel 控制台（懒加载），监控上了8401
            1.Sentinel采用懒加载说明，执行一次调用即可 http:localhost:8401/sentinel/testA

    7.Sentinel 流控规则
        1.基本介绍，新增流控规则界面已截图，下面针对图形名词解释
            1.资源名：唯一名称，默认请求路径
            2.针对来源：Sentinel可以针对调用者进行限流，填写微服务名，默认default(不区分来源)
            3.阈值类型/单机阈值：
                QPS(每秒钟的请求数量)：当调用该api的QPS达到阈值的时候，进行限流(拦截在服务外)
                线程数：当调用该api的线程数达到阈值的时候，进行限流(拦截在服务内，线程池超过阈值？)
            4.是否集群：不需要集群(课程讲解不使用)
            5.流控模式：
                直接：api达到限流条件时，直接限流
                关联：当关联的资源达到阈值时，就限流自己
                链路：只记录指定链路上的流量(指定资源从入口资源进来的流量，如果达到阈值，就进行限流)[api级别的针对来源]
            6.流控效果：
                快速失败：直接失败，抛异常
                Warm UP：根据codeFactor(冷加载因子，默认3)的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值
                排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效
        2.流控模式
            1.直接(系统默认)，阈值修改就能快速反应，不像hystrix要重启
                1.配置方式：簇点链路菜单->列表视图-> /sentinel/testA ->流控+
                    ->资源名：默认
                    ->针对来源：默认
                    ->阈值类型：QPS ，单机阈值 1
                    ->流控模式:直接
                    ->流控效果:快速失败
                2.(快速访问)http://localhost:8401/sentinel/testA 页面返回 Blocked by Sentinel (flow limiting)
                    直接调用默认报错信息<Blocked by Sentinel (flow limiting)>，技术方面OK，
                        源码 com.alibaba.csp.sentinel.slots.block.BlockException
                        但是也可以添加自己的后续处理，后续讲解
            2.关联
                1.是什么
                    1.当关联的资源达到阈值时，就限流自己
                    2.即当与A关联的资源B达到阈值后，就限流A自己
                    3.结果：B惹事了，A背锅(比如支付接口达到阈值后，限流下订单的接口，连坐)
                2.配置A
                    >资源名：默认(/sentinel/testA)
                    ->针对来源：默认
                    ->阈值类型：QPS ，单机阈值 1
                    ->流控模式:关联
                    ->关联资源：/sentinel/testB (这时设置的QPS阈值 只对B有效)
                    ->流控效果:快速失败
                3.postman模拟并发密集访问testB
                4.运行后发现A挂了
            3.链路
                多个请求调用了同一个微服务
        3.流控效果
            1.快速失败：直接失败，抛异常  Blocked by Sentinel (flow limiting)
                源码：com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController
            2.Warm UP：根据codeFactor(冷加载因子，默认3)的值，从阈值/codeFactor，经过预热时长，才达到设置的QPS阈值
                Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系统长期处于低水位的情况下，
                当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间
                内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮
                源码：com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController
            3.排队等待：匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效
                设置含义：/sentinel/testA 每秒1次请求，超过就排队等待，等待的超时时间为20000毫秒
                源码：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController

    8.Sentinel 熔断降级
        1.官网 https://github.com/alibaba/Sentinel/wiki/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7
        2.概述
            除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，
            可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个
            商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，
            请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身
            也变得不可用。
        3.特点
            1.异常降级仅针对业务异常，对 Sentinel 限流降级本身的异常（BlockException）不生效
            2.触发降级时，时间窗口结束时间内，对该资源的调用都自动熔断(默认行为是抛出DegradeException)
            3.Sentinel 的断路器是 没有半开状态的
        4.降级参数设置说明：
            1.RT(平均响应时间，秒级)
                平均响应时间 超出阈值 且 在时间窗口期内通过的请求>=5，两个条件同时满足后触发降级，窗口期过后关闭断路器。
            2.异常比例(秒级)
                QPS >= 5 且异常比例(秒级统计)超过阈值时，触发降级；时间窗口结束后关闭降级
            3.异常数(分钟级)
                异常数超过阈值时，触发降级；时间窗口结束后关闭降级

    9.热点key限流
        1.官网 https://github.com/alibaba/Sentinel/wiki/%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81
        2.大纲
            1.何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。比如：
                商品 ID 为参数，统计一段时间内最常购买的商品 ID 并进行限制
                用户 ID 为参数，针对一段时间内频繁访问的用户 ID 进行限制
            2.热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以
                看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。
            3.Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。热点参数限流支持集群模式
        3.@SentinelResource = @HystrixCommand
            1.Controller 接口方法上注解 @SentinelResource(value = "testHotKey", blockHandler = "deal_testHotKey")
                value = "testHotKey" 就变成 热点规则 的 资源名了。blockHandler = "deal_testHotKey" 就是兜底方法；这种注解
                方式这两个参数都必须要，因为使用@SentinelResource后，Sentinel默认兜底方法对此热点资源失效
            2.@SentinelResource 处理的是Sentinel控制台配置的违规异常情况，有blockHandler兜底方法
                RuntimeException 是java运行时报出的运行时异常，@SentinelResource 不管
        4.热点限流配置(普通版)
             >资源名：testHotKey
            ->限流模式：QPS
            ->参数索引: 0 表示Controller接口的第一个参数，有带这个参数才能受到热点限流保护
            ->单机阈值： 1
            ->统计窗口时长: 1
        5.热点限流配置(参数例外项--特例)
            普通版：超过1秒钟一个后，达到阈值1后立马限流
            特例：我们希望p1参数当它是某个特殊值时，它的限流值和平时不一样，可以是另外一个限流值；这时就可以通过 参数例外项 补充

    10.系统规则(粒度太大不适合，一般配置在网关Gateway比较合适)
        1.官网 https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81
        2.是什么：
            Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发
                线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大
                吞吐量的同时保证系统整体的稳定性
        3.系统规则支持以下的模式：
            1.Load 自适应（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设
                定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的
                maxQps * minRt 估算得出。设定参考值一般是 CPU cores * 2.5。
            2.CPU usage（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。
            3.平均 RT：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。
            4.并发线程数：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。
            5.入口 QPS：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。

    11.@SentinelResource详细讲解
        1.按资源名称限流 + 后续处理
            添加业务类RateLimitController
            @SentinelResource(value = "byResource", blockHandler = "byResourceHandle")
            方法1
        2.按URL地址限流 + 后续处理
            @SentinelResource(value = "byUrl")
            @GetMapping("/sentinel/byUrl")
            方法2   也可以在sentinel控制台对 资源名 /sentinel/byUrl 进行限流
        3.上面兜底方法面临的问题
            1.兜底方法与业务代码耦合，不直观
            2.系统默认限流兜底方法不满足业务要求
            3.每隔业务方法都需要兜底，代码膨胀
            4.缺全局统一处理方法
        4.客户自定义限流处理逻辑
            1.创建CustomerBlockHandler 用于自定义限流处理逻辑、自定义限流处理类，做统一兜底方法
            2.CustomerBlockHandler 的方法必须是static ，且返回 CommonResult 方便前端处理，无需注入到Spring容器(因为静态？)
            3.@SentinelResource(value = "customerBlockHandler", blockHandlerClass = CustomerBlockHandler.class
                , blockHandler = "handlerBlockException2")
        5.更多注解属性说明
            1.@SentinelResource注解方式的埋点不支持private方法
            2.Sentinel限流，所有代码都是try-catch-finally处理
    12.服务熔断功能(重点)
        1.sentinel整合ribbon + openFeign + fallback
        2.Ribbon系列
            1.提供者：
                1.新建cloudalibaba-provider-payment9003/9004
                2.pom、yml、主启动类同9001
            2.消费者 cloudalibaba-consumer-nacos-order8001
                pom/yml 同 cloudalibaba-sentinel-service8401
                1.spring-cloud-starter-alibaba-nacos-discovery
                2.spring-cloud-starter-alibaba-sentinel
                3.业务类
                    1.@SentinelResource(value = "fallback")
                        //没配置熔断、限流兜底方法，业务异常返回出错页面，不友好
                    2.@SentinelResource(value = "fallback", fallback = "handlerFallBack")
                        //fallback只负责业务异常，fallback 方法可传入 Exception 参数
                    3.@SentinelResource(value = "fallback", blockHandler = "blockHandler")
                        //blockHandler只负责sentinel控制台限流配置违规，blockHandler 方法只能传入 BlockException 参数
                    4.@SentinelResource(value = "fallback", blockHandler = "blockHandler", fallback = "handlerFallBack")
                        //两个都配(就是绝配，降级限流优秀框架)，当达到sentinel配置的QPS限流降级时，调用的是blockHandler 兜底方法
                    5.异常忽略
                        @SentinelResource(value = "fallback", blockHandler = "blockHandler", fallback =
                            "handlerFallBack" , exceptionsToIgnore = {IllegalArgumentException.class})
                        //如果报该IllegalArgumentException异常，不再有fallback方法兜底，没有降级效果了
        3.Feign系列
            1.Feign组件一般在消费侧
            2.新建 cloudalibaba-consumer-nacos-feign-order8002模块
            3.pom
                1.spring-cloud-starter-alibaba-nacos-discovery
                2.spring-cloud-starter-alibaba-sentinel
                3.spring-cloud-starter-openfeign
            4.yml
                server:
                  port: 8002

                spring:
                  application:
                    name: nacos-sentinel-feign-order-consumer
                  cloud:
                    nacos:
                      discovery:
                        #nacos 服务注册中心地址
                        server-addr: 127.0.0.1:8848
                    sentinel:
                      transport:
                        #配置 sentinel dashboard 地址
                        dashboard: 127.0.0.1:8080
                        #默认8719端口，假如被占用会自动依次从8719+1扫描，直至找到未被占用的端口
                        port: 8719

                #自定义配置，消费者访问微服务名称
                service-url:
                  nacos-user-service: http://nacos-sentinel-payment-provider


                #激活sentinel，对feign的支持。同feign:hystrix:enabled: true意义一样，当服务提供方不可用时，全局兜底方法返回结果
                feign:
                  sentinel:
                    enabled: true
            5.主启动
                @SpringBootApplication
                @EnableDiscoveryClient
                @EnableFeignClients //启用feign客户端
            6.业务类
                1.SentinelFeignPaymentService 接口 : @FeignClient(value = "${service-url.nacos-user-service}", fallback = SentinelFeignPaymentFallbackService.class)
                2.SentinelFeignPaymentFallbackService implements SentinelFeignPaymentService 全局服务降级兜底类 @Service
                3.controller
                        没配置blockHandler，fallback；降级时走默认全局熔断兜底方法，sentinel控制台限流配置违规时页面报异常，客户端运行错误走页面报错
                        @SentinelResource(value = "sentinelfeign")

                        没配置blockHandler，配置fallback；降级时走默认全局熔断兜底方法，sentinel控制台限流配置违规时走fallback，客户端运行错误走fallback兜底
                        @SentinelResource(value = "sentinelfeign", fallback = "handlerFallBack")

                        没配置fallback，配置blockHandler；降级时走默认全局熔断兜底方法，sentinel控制台限流配置违规时走blockHandler，客户端运行错误走页面报错
                        @SentinelResource(value = "sentinelfeign", blockHandler = "blockHandler")

                        配置fallback，配置blockHandler；降级时走默认全局熔断兜底方法，sentinel控制台限流配置违规时走blockHandler，客户端运行错误走fallback兜底
                        @SentinelResource(value = "sentinelfeign", blockHandler = "blockHandler", fallback = "handlerFallBack")

                        配置fallback，blockHandler，exceptionsToIgnore；降级时走默认全局熔断兜底方法(IllegalArgumentException除外)，
                        sentinel控制台限流配置违规时走blockHandler，客户端运行错误走fallback兜底(IllegalArgumentException除外),IllegalArgumentException走页面报错
                        @SentinelResource(value = "sentinelfeign", fallback = "handlerFallBack", blockHandler = "blockHandler",
                                exceptionsToIgnore = {IllegalArgumentException.class})

        4.熔断框架比较
                        Sentinel                        Hystrix(过时)        resilience4j(国外流行)
            隔离策略     信号量隔离(并发线程数限流)         线程池/信号量隔离     信号量隔离
            熔断降级策略  基于响应时间、异常比率、异常数     基于异常比率          基于响应时间、异常比率
            实时统计实现  滑动窗口(LeapArray)             滑动窗口(RxJava)      Ring Bit Buffer
            动态规则配置  支持多种数据源                   支持多种数据源        有限支持
            扩展性       多个扩展点                       插件形式             接口形式
            基于注解支持  支持                            支持                 支持
            限流         基于QPS，支持基于调用关系的限流    有限的支持           Rate Limiter

    13.规则持久化
        1.默认启动Sentinel对限流规则未做持久化，重启所有限流熔断降级配置全部丢失
        2.以cloudalibaba-sentinel-service8401做案例说明
        3.将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要nacos里面配置
            不删除，针对8401上的sentinel上流控规则持续有效
        4.步骤：
            1.pom依赖添加
                原来依赖基础上添加 sentinel-datasource-nacos
            2.yml
                spring:
                  application:
                    name: cloudalibaba-sentinel-service
                  cloud:
                    nacos:
                      discovery:
                        #nacos 服务注册中心地址
                        server-addr: 127.0.0.1:8848
                    sentinel:
                      transport:
                        #配置 sentinel dashboard 地址
                        dashboard: 127.0.0.1:8080
                        #默认8719端口，假如被占用会自动依次从8719+1扫描，直至找到未被占用的端口
                        port: 8719
                      #添加sentinel数据源,将限流配置规则持久化进Nacos保存
                      datasource:
                        ds1:
                          nacos:
                            server-addr: ${spring.cloud.nacos.discovery.server-addr}
                            dataId: ${spring.application.name}
                            groupId: DEFAULT_GROUP
                            data-type: json
                            rule-type: flow
            3.添加nacos业务规则配置
                1.在nacos配置中心添加配置cloudalibaba-sentinel-service，json格式
                2.内容
                    [{
                        "resource": "customerBlockHandler",   资源名称
                        "limitApp": "default",                来源应用
                        "grade": 1,                           阈值类型：0表示线程，1表示QPS
                        "count": 1,                           单机阈值
                        "strategy": 0,                        流控模式(策略)：0表示直接，1表示关联，2表示链路
                        "controlBehavior": 0,                 流控效果：0快速失败，1 WarmUp，2排队等待
                        "clusterMode": false                  是否集群
                    }]
            4.启动8401后，访问http://localhost:8401/sentinel/customerBlockHandler，刷新sentinel发现限流规则有了；
                快速访问测试接口，看到限流兜底方法生效；停止8401再看sentinel上该流控规则消失了；重启8401后访问
                http://localhost:8401/sentinel/customerBlockHandler再看sentinel上流控规则出现，持久化完成。


SpringCloud Alibaba Seata处理分布式事务
    1.分布式事务问题
        1.单机单库没有这个问题（1_APP：1数据库）
        2.分库（1_APP：N数据库，N_APP：N数据库）
        3.案例：单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用
            三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。
        4.一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。
    2.Seata简介
        1.是什么：Seata是一款开源的分布式事务解决方案，致力于在微服务架构中提供高性能和简单易用的分布式事务服务
            官网：http://seata.io/zh-cn/
        2.能干嘛
            1.一个典型的分布式事务过程
                1.分布式事务处理过程的 一ID+三组件模型
                    1.TransactionID XID ：全局唯一的事务ID
                    2.三组件概念
                        1.Transaction Coordinator（TC）：事务协调器，维护全局和分支事务的状态，驱动全局事务提交或回滚。
                        2.Transaction Manager（TM）：事务管理器，定义全局事务的范围：开始全局事务、提交或回滚全局事务。
                        3.Resource Manager（RM）：资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，
                            并驱动分支事务提交或回滚。
                2.处理过程 https://www.bilibili.com/video/BV1zi4y1872h?p=139
                    1.
        3.去哪下载
        4.怎么玩
    3.Seata-Server安装
    4.订单/库存/账户业务数据库准备
    5.订单/库存/账户业务微服务准备
    6.测试




































DDL*******************************************************************************
CREATE TABLE public.payment (
	id bigserial PRIMARY key,
	serial varchar(200) default ''
)
WITH (
	OIDS=FALSE
) ;

-- Permissions
GRANT ALL ON TABLE public.payment TO zbscm;




























<!-- sql:里面可以写入一个共同的sql代码，用于提取重复的代码。
        要使用该代码的时候就直接使用<include>标签
        id:为提取的sql代码，取一个id，起标识作用
         -->
    <sql id="select">
        select * from user
    </sql>
    <!-- public User findUserById(int id);
        id:填写在XxxMapper接口中的方法名
        parameterType:填写参数的类型
        resultType:填写方法中返回值的类型，不用写全路径，不区分大小写
    -->
    <select id="findUserById" parameterType="int" resultType="user">
        <!-- include:用于加载提取公共的sql语句，与<sql>标签对应
               refid:填写<sql>标签中的id属性
         -->
        <include refid="select"></include>
        where id = #{id}
    </select>
    <!-- resultMap属性:与resultMap标签一起使用，填写resultMap标签中定义的id属性 -->
    <select id="findAllOrders" resultMap="orders">
        select * from orders
    </select>
    <!-- resultMap标签:用于自定义封装结果
        type:最终结果还是封装到实体类中，type就是指定封装到哪一个类中
        id:与<select>标签中的resultMap中的属性一直，一定要唯一
        <id>:该标签是指定主键封装到实体类中的哪一个属性(可以省略)
        <result>:该标签是其他的列封装到实体类中，一般只需填写实体类中的属性与表中列不同的项即可
            property:填写实体类中的属性，column:填写表中的列名
     -->
    <resultMap type="Orders" id="orders">
        <id property="id" column="id"/>
        <result property="userId" column="user_id"/>
    </resultMap>
    <!--  public void addUser(User user);
        insert:用于执行添加语句；update:执行更新语句
       同样 delete:执行删除语句
     -->
    <insert id="addUser" parameterType="user">
        <!-- selectKey配置主键信息的标签
            keyColumn:对应数据库表中的主键列
            keyProperty:对应实体类中的属性
            after:代表执行下面代码之前，先执行当前里面的代码
         -->
        <selectKey keyColumn="id" keyProperty="id" order="AFTER" resultType="int">
            select LAST_INSERT_ID()
        </selectKey>
        insert into user
        (username,sex,address)
        values(#{username},#{sex},#{address})
    </insert>
    <!-- public List<User> findUserBySexAndUsername(User user); -->
    <select id="findUserBySexAndUsername" parameterType="User" resultType="user">
        <!--select * from user  where 1=1 -->
        <include refid="select"></include>
        <!-- where标签:一个where条件语句，通常和<if>标签混合使用 -->
        <where>
            <!-- if标签:执行一个判断语句，成立才会执行标签体内的sql语句
                test:写上条件判断语句
                注意:这里每一个if前面都尽量加上and，如果你是第一个条件，框架会自动帮你把and截取，如果是第二个if就不能省略and
             -->
            <if test="sex != null and sex != ''">
                and sex = #{sex}
            </if>
            <if test="username != null and username != ''">
                and username like '%${username}%'
            </if>
        </where>
    </select>

    <!-- public List<User> findUserByIds(QueryVo vo); -->
    <!-- QueryVo:是一个实体包装类，通常用于封装实体类之外的一些属性-->
    <select id="findUserByIds" parameterType="QueryVo" resultType="user">
        <include refid="select"></include>
        <where>
            <!-- foreach:循环语句，通常多用于参数是集合时，需要对参数进行遍历出来，再进行赋值查询
                collection:参数类型中的集合、数组的名字，例：下面的ids就是QueryVo这个类中的list集合的名字
                item:为遍历该集合起一个变量名，遍历出来的每一个字，都赋值到这个item中
                open:在sql语句前面添加的sql片段
                close:在sql语句后面添加的sql片段
                separator:指定遍历元素之前用什么分隔符
             -->
            <foreach collection="ids" item="id" open="id in(" close=")" separator=",">
                #{id}
            </foreach>
        </where>
    </select>




JDBC Type           Java Type
CHAR                String
VARCHAR             String
LONGVARCHAR         String
NUMERIC             java.math.BigDecimal
DECIMAL             java.math.BigDecimal
BIT             boolean
BOOLEAN             boolean
TINYINT             byte
SMALLINT            short
INTEGER             int
BIGINT              long
REAL                float
FLOAT               double
DOUBLE              double
BINARY              byte[]
VARBINARY           byte[]
LONGVARBINARY               byte[]
DATE                java.sql.Date
TIME                java.sql.Time
TIMESTAMP           java.sql.Timestamp
CLOB                Clob
BLOB                Blob
ARRAY               Array
DISTINCT            mapping of underlying type
STRUCT              Struct
REF                         Ref
DATALINK            java.net.URL[color=red][/color]